All files                                |   78.85 |    71.44 |   80.35 |   79.05 |
 src                                     |    72.6 |    62.88 |   77.12 |   73.13 |
  aiService.js                           |   91.04 |    74.19 |     100 |   91.04 | 199-236
  auth.js                                |   61.11 |    38.29 |   66.66 |   62.79 | 33-46,82-83,87-88,110,141,160-165,169-183,224-229,238-241,252-255,282-283,306,327,354,366,388-399,406-416,439
  bot.js                                 |   97.22 |      100 |     100 |   97.22 | 35
  commandLoader.js                       |     100 |      100 |     100 |     100 |
  commandProcessor.js                    |   98.27 |    94.11 |     100 |   98.27 | 26
  commandValidation.js                   |   91.83 |    70.45 |     100 |   91.83 | 87-96
  constants.js                           |     100 |      100 |     100 |     100 |
  dataStorage.js                         |   78.78 |    66.66 |     100 |   78.78 | 57-70
  healthCheck.js                         |   96.07 |    92.59 |     100 |   97.95 | 135
  httpServer.js                          |   88.13 |       88 |   71.42 |   88.13 | 115,122,129,136,140-142
  logger.js                              |   91.66 |    73.68 |     100 |   96.96 | 84
  messageTracker.js                      |     100 |      100 |     100 |     100 |
  middleware.js                          |   96.59 |    91.89 |     100 |   96.55 | 21,127-128
  profileInfoFetcher.js                  |    98.3 |    95.83 |   91.66 |    98.3 | 162
  utils.js                               |   94.28 |      100 |      80 |   93.33 | 10-11
  webhookManager.js                      |       0 |        0 |       0 |       0 | 18-591
  webhookServer.js                       |   82.27 |    75.86 |   81.81 |   82.27 | 76-80,85-86,141-153,172,180
 src/adapters                            |    85.1 |    71.42 |   71.42 |    85.1 |
  CommandIntegrationAdapter.js           |   84.44 |    71.42 |   71.42 |   84.44 | 51-52,151,178-179,250-258,269-282
  index.js                               |     100 |      100 |     100 |     100 |
 src/adapters/ai                         |   27.77 |    32.24 |   51.35 |   27.63 |
  AIServiceAdapterFactory.js             |   95.38 |    81.17 |     100 |   95.23 | 94,188,249
  HttpAIServiceAdapter.js                |       0 |        0 |       0 |       0 | 1-488
  index.js                               |     100 |      100 |     100 |     100 |
 src/adapters/discord                    |   92.89 |    90.78 |   94.11 |   93.16 |
  DiscordMessageAdapter.js               |    90.9 |       92 |      90 |   91.46 | 54-55,182-184,225,232
  DiscordWebhookAdapter.js               |   94.87 |     87.8 |     100 |   94.73 | 163,203,217-218
  index.js                               |     100 |      100 |     100 |     100 |
 src/adapters/persistence                |   70.99 |    43.26 |   69.73 |   71.06 |
  FileAuthenticationRepository.js        |   95.38 |    75.53 |     100 |   96.82 | 324,352-356,438,445
  FileConversationRepository.js          |     100 |    77.58 |     100 |     100 | 29-31,98-100,152-153,184,284,291,342,365-366
  FilePersonalityRepository.js           |       0 |        0 |       0 |       0 | 1-594
  MemoryConversationRepository.js        |     100 |    78.46 |     100 |     100 | 17-20,57,118,174,211-223,255,264,277,342
  index.js                               |     100 |      100 |     100 |     100 |
 src/application/bootstrap               |       0 |        0 |       0 |       0 |
  ApplicationBootstrap.js                |       0 |        0 |       0 |       0 | 6-352
 src/application/commands                |   81.51 |    52.06 |   85.48 |   81.28 |
  CommandAbstraction.js                  |   62.82 |    43.62 |      80 |   62.09 | 177,202,235-391
  CommandAdapter.js                      |   96.42 |    72.41 |   84.61 |   96.38 | 38,84,202
  CommandIntegration.js                  |     100 |    93.75 |     100 |     100 | 171
 src/application/commands/authentication |   96.08 |    85.71 |     100 |   96.06 |
  AuthCommand.js                         |   94.21 |    84.28 |     100 |   94.21 | 134-156,414,534-556
  VerifyCommand.js                       |     100 |    89.28 |     100 |     100 | 197-311
 src/application/commands/conversation   |   43.05 |    27.88 |   78.57 |   43.05 |
  ActivateCommand.js                     |    17.5 |     2.77 |     100 |    17.5 | 43-150
  AutorespondCommand.js                  |      20 |     5.55 |      50 |      20 | 51-185
  DeactivateCommand.js                   |      24 |    14.28 |     100 |      24 | 33-96
  ResetCommand.js                        |   95.45 |    60.46 |     100 |   95.45 | 86-92
 src/application/commands/personality    |   85.66 |     75.1 |      80 |   86.26 |
  AddCommand.js                          |   97.36 |     93.5 |     100 |   97.36 | 291,322
  AliasCommand.js                        |   71.92 |    57.14 |   66.66 |   73.21 | 170-212,218-234,238-258
  InfoCommand.js                         |      65 |    40.62 |   66.66 |      65 | 56,87-139
  ListCommand.js                         |   97.87 |    91.66 |     100 |   97.87 | 139
  RemoveCommand.js                       |   87.87 |    71.73 |   66.66 |   89.23 | 90-102,181-182,192,224-240
 src/application/commands/utility        |   96.63 |    83.59 |      90 |    96.8 |
  DebugCommand.js                        |     100 |    79.16 |     100 |     100 | 16,26,28-30
  HelpCommand.js                         |    96.8 |    87.01 |     100 |   96.66 | 138-150
  NotificationsCommand.js                |    97.1 |    89.13 |     100 |    97.1 | 70-71
  PingCommand.js                         |     100 |    66.66 |     100 |     100 | 16
  PurgbotCommand.js                      |   92.13 |    80.64 |   61.53 |   93.18 | 77-78,93-95,240
  StatusCommand.js                       |   96.77 |    87.83 |      80 |   96.55 | 43,169
  VolumeTestCommand.js                   |     100 |    70.27 |     100 |     100 | 16,22,73-83,107,119-142
 src/application/eventHandlers           |   94.73 |       70 |     100 |   94.66 |
  EventHandlerRegistry.js                |     100 |      100 |     100 |     100 |
  PersonalityCacheInvalidator.js         |   88.57 |       70 |     100 |   88.57 | 39,68,89,116
  PersonalityEventLogger.js              |     100 |      100 |     100 |     100 |
 src/application/routers                 |   95.65 |    64.58 |     100 |   95.58 |
  PersonalityRouter.js                   |   95.65 |    64.58 |     100 |   95.58 | 90,186-187
 src/application/services                |   47.22 |     54.4 |   74.13 |   46.34 |
  ComparisonTester.js                    |   93.28 |    88.17 |     100 |   92.91 | 109,128,198-202,217-223,264
  FeatureFlags.js                        |   98.18 |      100 |   95.23 |   98.14 | 74
  PersonalityApplicationService.js       |       0 |        0 |       0 |       0 | 1-578
 src/commands                            |   68.62 |    36.36 |      80 |      68 |
  index.js                               |   68.62 |    36.36 |      80 |      68 | 53,60-72,86-89,95-96,124-126
 src/commands/handlers                   |   60.11 |    53.59 |   40.56 |   60.78 |
  activate.js                            |   90.62 |       75 |     100 |   90.62 | 94-98
  add.js                                 |   77.69 |    61.33 |      25 |   77.69 | 48-49,55-58,73,104-107,116-119,280,302,320-364
  alias.js                               |      88 |       75 |     100 |      88 | 71-75
  auth.js                                |   94.11 |       90 |   85.71 |   94.11 | 75-76,108,147-148,293
  autorespond.js                         |     100 |    83.33 |     100 |     100 | 54,64
  backup.js                              |    3.55 |        0 |       0 |    3.66 | 33,42-452,464-1066,1107-1118
  deactivate.js                          |      95 |      100 |     100 |      95 | 62
  debug.js                               |      96 |      100 |     100 |      96 | 129-130
  help.js                                |   83.56 |    80.95 |   85.71 |    84.5 | 98-108,159-166,213-217
  info.js                                |   60.71 |       25 |     100 |   60.71 | 57-89
  list.js                                |     100 |      100 |     100 |     100 |
  notifications.js                       |   90.74 |    86.36 |     100 |   90.74 | 134-135,180-184
  ping.js                                |     100 |      100 |     100 |     100 |
  purgbot.js                             |   88.09 |    69.09 |    62.5 |   89.02 | 91-92,115-116,136-137,193-194,247
  remove.js                              |      95 |    83.33 |     100 |      95 | 76,88
  reset.js                               |     100 |     87.5 |     100 |     100 | 59
  status.js                              |   94.11 |    60.52 |     100 |   95.74 | 106,117
  verify.js                              |   91.66 |    76.47 |   33.33 |   94.28 | 91,112
  volumetest.js                          |     100 |    81.25 |     100 |     100 | 59-69,102
 src/commands/middleware                 |     100 |      100 |     100 |     100 |
  auth.js                                |     100 |      100 |     100 |     100 |
  deduplication.js                       |     100 |      100 |     100 |     100 |
  permissions.js                         |     100 |      100 |     100 |     100 |
 src/commands/utils                      |      77 |    69.04 |      78 |   77.17 |
  commandLoader.js                       |   75.86 |    66.66 |     100 |      75 | 34,42-47,63-64,78
  commandRegistry.js                     |   93.18 |    94.44 |      85 |   93.02 | 94,111,116
  commandValidator.js                    |     100 |      100 |     100 |     100 |
  messageTracker.js                      |   65.62 |    52.08 |   65.21 |   66.31 | 15-16,64-84,98-109,142-143,200,264-265,317-333
 src/core/api                            |   75.83 |    71.76 |      68 |   76.19 |
  ProfileInfoCache.js                    |   73.33 |    73.68 |      70 |   73.33 | 36,92-96,111-113
  ProfileInfoClient.js                   |     100 |      100 |     100 |     100 |
  ProfileInfoFetcher.js                  |   65.43 |    54.76 |   54.54 |   66.25 | 22,52-53,131-134,146,151-162,167-179,187-210
  index.js                               |     100 |      100 |     100 |     100 |
 src/core/authentication                 |   97.96 |    91.62 |     100 |    98.4 |
  AIClientFactory.js                     |     100 |    94.11 |     100 |     100 | 59
  AuthManager.js                         |     100 |    93.75 |     100 |     100 | 90,195
  AuthPersistence.js                     |      92 |    72.22 |     100 |   93.87 | 145,157,163-164,235-236
  NsfwVerificationManager.js             |     100 |    95.65 |     100 |     100 | 125,161
  PersonalityAuthValidator.js            |   98.46 |    86.95 |     100 |   98.41 | 100
  UserTokenManager.js                    |     100 |      100 |     100 |     100 |
  index.js                               |     100 |      100 |     100 |     100 |
 src/core/conversation                   |   83.73 |    84.27 |   74.69 |   84.09 |
  AutoResponder.js                       |   83.33 |    66.66 |    62.5 |   88.23 | 53,72
  ChannelActivation.js                   |   81.81 |     87.5 |      75 |   81.81 | 95-99,111,122
  ConversationManager.js                 |   78.09 |    76.19 |   80.55 |   78.09 | 64-65,235-245,260-261,272-273,289-307,317,346-350
  ConversationPersistence.js             |   60.78 |    71.42 |   36.36 |   60.78 | 45-68,115-122,157-166
  ConversationTracker.js                 |   94.28 |     87.3 |    87.5 |   94.28 | 153,261,294,330-332
  MessageHistory.js                      |   94.73 |    93.93 |     100 |   96.29 | 135-138
  index.js                               |     100 |      100 |     100 |     100 |
 src/core/notifications                  |   97.27 |    93.41 |   94.54 |   97.63 |
  GitHubReleaseClient.js                 |   98.07 |    94.02 |     100 |   98.05 | 20,53
  ReleaseNotificationManager.js          |   95.15 |     92.3 |   86.95 |    96.2 | 27-28,195-196,234,362
  UserPreferencesPersistence.js          |   97.64 |     92.5 |     100 |   97.56 | 90-91
  VersionTracker.js                      |     100 |    97.67 |     100 |     100 | 141
  index.js                               |     100 |       50 |     100 |     100 | 22
 src/core/personality                    |   82.25 |     86.3 |    67.9 |   82.07 |
  PersonalityManager.js                  |   77.82 |    83.87 |   53.33 |    77.6 | ...70,83-84,100,139,153-154,190-192,197,249-250,274,283-284,306-307,329,353,391,405,495,523-524,538-543,550-564,588-589,606,633,644-646,648-658
  PersonalityPersistence.js              |   50.79 |       50 |      40 |   50.79 | 83-150
  PersonalityRegistry.js                 |   96.92 |     88.7 |   90.47 |   96.89 | 38,113,200-201
  PersonalityValidator.js                |   95.29 |    94.44 |     100 |   95.12 | 33,107,176,227
  index.js                               |     100 |      100 |     100 |     100 |
 src/domain/ai                           |   97.39 |    97.38 |   94.93 |   97.36 |
  AIContent.js                           |   97.43 |    96.29 |     100 |   97.22 | 61
  AIEvents.js                            |     100 |      100 |     100 |     100 |
  AIModel.js                             |     100 |      100 |     100 |     100 |
  AIRequest.js                           |     100 |      100 |     100 |     100 |
  AIRequestDeduplicator.js               |      90 |     87.5 |   73.33 |      90 | 130-131,154-158,164
  AIRequestId.js                         |     100 |      100 |     100 |     100 |
  AIRequestRepository.js                 |     100 |      100 |     100 |     100 |
  AIService.js                           |     100 |      100 |     100 |     100 |
  index.js                               |     100 |      100 |     100 |     100 |
 src/domain/authentication               |     100 |    99.24 |     100 |     100 |
  AuthContext.js                         |     100 |      100 |     100 |     100 |
  AuthenticationEvents.js                |     100 |      100 |     100 |     100 |
  AuthenticationRepository.js            |     100 |      100 |     100 |     100 |
  NsfwStatus.js                          |     100 |      100 |     100 |     100 |
  Token.js                               |     100 |      100 |     100 |     100 |
  TokenService.js                        |     100 |      100 |     100 |     100 |
  UserAuth.js                            |     100 |    97.77 |     100 |     100 | 90
  index.js                               |     100 |      100 |     100 |     100 |
 src/domain/conversation                 |   98.21 |    95.23 |   98.48 |   98.19 |
  ChannelActivation.js                   |     100 |      100 |     100 |     100 |
  Conversation.js                        |   98.78 |    92.98 |     100 |   98.78 | 199
  ConversationEvents.js                  |      85 |       84 |   83.33 |      85 | 90-93
  ConversationId.js                      |     100 |      100 |     100 |     100 |
  ConversationRepository.js              |     100 |      100 |     100 |     100 |
  ConversationSettings.js                |     100 |      100 |     100 |     100 |
  Message.js                             |     100 |      100 |     100 |     100 |
  index.js                               |     100 |      100 |     100 |     100 |
 src/domain/personality                  |   90.55 |    85.47 |   91.39 |   90.78 |
  Alias.js                               |   95.65 |    88.88 |     100 |   95.65 | 78
  ExtendedPersonalityProfile.js          |      75 |    82.48 |   53.84 |   77.58 | 124,128,132,136-176,239,288
  Personality.js                         |   93.47 |    79.68 |     100 |   93.25 | 100,158,162,185,189,242
  PersonalityConfiguration.js            |     100 |      100 |     100 |     100 |
  PersonalityDataRepository.js           |   81.37 |    41.02 |   84.61 |      81 | 60-63,125,191,204-206,233-259
  PersonalityEvents.js                   |     100 |      100 |     100 |     100 |
  PersonalityId.js                       |     100 |      100 |     100 |     100 |
  PersonalityProfile.js                  |   97.05 |    95.12 |     100 |   96.96 | 114,122,126
  PersonalityRepository.js               |     100 |      100 |     100 |     100 |
  UserId.js                              |     100 |      100 |     100 |     100 |
  index.js                               |     100 |      100 |     100 |     100 |
 src/domain/shared                       |     100 |      100 |   97.05 |     100 |
  AggregateRoot.js                       |     100 |      100 |      90 |     100 |
  DomainEvent.js                         |     100 |      100 |     100 |     100 |
  DomainEventBus.js                      |     100 |      100 |     100 |     100 |
  ValueObject.js                         |     100 |      100 |     100 |     100 |
  index.js                               |     100 |      100 |     100 |     100 |
 src/handlers                            |   63.29 |    49.05 |   58.44 |   63.39 |
  dmHandler.js                           |    7.08 |        0 |       0 |    7.14 | 24-324
  errorHandler.js                        |   82.92 |       75 |   72.22 |   81.81 | 132-135,146,163-179,213
  messageHandler.js                      |    82.7 |    69.87 |   71.42 |   83.14 | 39-40,54-55,111-140,189,208,213-226,243,266,291,298-299,352,390-402,467,501,598,638,644,710,725,731
  messageTrackerHandler.js               |   70.52 |     61.7 |    64.7 |   71.91 | 10-18,30-48,63-69,77-78,110,226-227,244,260-262
  personalityHandler.js                  |   45.17 |    25.33 |      40 |   45.52 | 36-39,75-81,204-458,466-503,524-543,583-630,801,805,819
  referenceHandler.js                    |    87.7 |    74.69 |     100 |    87.7 | 132,146,151-154,192,269,349-353,369,391-398,474-480,499,513,521-529,535
 src/monitoring                          |      85 |    73.68 |   72.72 |      85 |
  deduplicationMonitor.js                |      85 |    73.68 |   72.72 |      85 | 75-76,116-123,138,160
 src/routes                              |   82.67 |    72.61 |   88.46 |   82.58 |
  avatars.js                             |   89.23 |       84 |   85.71 |   89.23 | 104-107,151-152,171
  health.js                              |   88.09 |       60 |    87.5 |    87.8 | 114,162-166
  webhooks.js                            |   75.78 |    73.52 |    90.9 |   75.78 | 27-28,59-60,68,76,81-82,148-151,165-168,193-200
 src/services                            |    6.32 |        0 |       0 |    6.41 |
  PersonalityDataService.js              |    6.32 |        0 |       0 |    6.41 | 16-247,260-263
 src/utils                               |   93.42 |    85.61 |   93.63 |   93.47 |
  LRUCache.js                            |   98.78 |    92.85 |     100 |   98.78 | 233
  aiAuth.js                              |     100 |       80 |     100 |     100 | 19-20
  aiErrorHandler.js                      |     100 |    93.69 |     100 |     100 | 57,123,155,169,193-194
  aiMessageFormatter.js                  |    87.2 |    80.95 |      70 |    87.2 | 284-288,308-311,393-406,412,455-482
  aiRequestManager.js                    |   94.68 |       90 |     100 |   94.04 | 196-207
  avatarManager.js                       |   76.66 |     61.7 |   72.72 |   76.87 | 30-31,105,204-219,233,249-250,259-285,330,367-371,380-384
  avatarStorage.js                       |   87.41 |    79.26 |     100 |   88.27 | 82,88-89,103-104,160,178,298,309-321,338-339,348
  channelUtils.js                        |     100 |    94.73 |     100 |     100 | 27
  contentSanitizer.js                    |   96.55 |       84 |     100 |   95.65 | 57
  contentSimilarity.js                   |     100 |      100 |     100 |     100 |
  embedBuilders.js                       |   89.42 |    74.46 |    90.9 |   89.42 | 131-138,168-179
  embedUtils.js                          |   97.27 |    93.47 |   92.85 |   98.11 | 221-222
  errorTracker.js                        |     100 |      100 |     100 |     100 |
  messageDeduplication.js                |     100 |       88 |     100 |     100 | 38-42
  messageFormatter.js                    |      97 |    94.11 |     100 |   96.93 | 100,250,274
  personalityAuth.js                     |     100 |       75 |     100 |     100 | 19-20,59-71,74
  pluralkitMessageStore.js               |   94.82 |    93.33 |   76.92 |   96.49 | 163,182
  rateLimiter.js                         |     100 |    97.61 |     100 |     100 | 67
  requestTracker.js                      |     100 |      100 |     100 |     100 |
  threadHandler.js                       |     100 |    94.59 |     100 |     100 | 174-199
  urlValidator.js                        |   96.96 |    97.61 |   77.77 |   96.72 | 16-17
  webhookCache.js                        |   93.06 |       75 |     100 |   92.92 | 88-89,122,151-155,299-300
  webhookUserTracker.js                  |   92.95 |    85.58 |   93.75 |   92.64 | 100-103,271-276,440-442
 src/utils/media                         |    89.5 |    81.25 |   86.66 |   90.96 |
  audioHandler.js                        |   88.46 |    84.12 |      80 |      90 | 99-101,106-108,113-123,293
  imageHandler.js                        |   78.84 |    64.61 |      80 |      81 | 40,97-123,153,155,193,266,295
  index.js                               |     100 |      100 |     100 |     100 |
  mediaHandler.js                        |   98.47 |    89.28 |     100 |   99.21 | 240
 src/webhook                             |   91.52 |    87.77 |   78.12 |    92.3 |
  dmHandler.js                           |   97.45 |     87.5 |      50 |   98.27 | 26,41
  errorUtils.js                          |     100 |      100 |     100 |     100 |
  index.js                               |       0 |      100 |     100 |       0 | 7-13
  messageThrottler.js                    |   91.07 |       80 |      75 |   91.07 | 31-32,71-72,185
  messageUtils.js                        |   84.53 |    87.69 |     100 |   84.53 | 104,113-126,135-138,252-253
  threadHandler.js                       |   94.44 |       84 |      50 |   97.08 | 38,156-157
-----------------------------------------|---------|----------|---------|---------|-------------------------------------------------------------------------------------------------------------------------------------------------
Summary of all failing tests
 FAIL  tests/unit/domain/ai/AIRequestDeduplicator.test.js
  ● AIRequestDeduplicator › checkDuplicate › should return existing promise for duplicate requests

    expect(received).toBe(expected) // Object.is equality

    Expected: {Symbol(async_id_symbol): 4675, Symbol(trigger_async_id_symbol): 4662}
    Received: "response"

      72 |
      73 |       const result = await deduplicator.checkDuplicate('TestBot', 'Hello');
    > 74 |       expect(result).toBe(promise);
         |                      ^
      75 |     });
      76 |
      77 |     it('should throw error for requests in blackout period', async () => {

      at toBe (tests/unit/domain/ai/AIRequestDeduplicator.test.js:74:22)
      at Generator.call (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)

  ● AIRequestDeduplicator › checkDuplicate › should be case-insensitive for personality names

    expect(received).toBe(expected) // Object.is equality

    Expected: {Symbol(async_id_symbol): 5223, Symbol(trigger_async_id_symbol): 5210}
    Received: "response"

      88 |
      89 |       const result = await deduplicator.checkDuplicate('testbot', 'Hello');
    > 90 |       expect(result).toBe(promise);
         |                      ^
      91 |     });
      92 |
      93 |     it('should consider context in deduplication', async () => {

      at toBe (tests/unit/domain/ai/AIRequestDeduplicator.test.js:90:22)
      at Generator.call (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)

  ● AIRequestDeduplicator › checkDuplicate › should consider context in deduplication

    expect(received).toBe(expected) // Object.is equality

    Expected: {Symbol(async_id_symbol): 5500, Symbol(trigger_async_id_symbol): 5487}
    Received: "response1"

      101 |       const result2 = await deduplicator.checkDuplicate('TestBot', 'Hello', { userAuth: 'user2' });
      102 |
    > 103 |       expect(result1).toBe(promise1);
          |                       ^
      104 |       expect(result2).toBe(promise2);
      105 |     });
      106 |   });

      at toBe (tests/unit/domain/ai/AIRequestDeduplicator.test.js:103:23)
      at Generator.call (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)

  ● AIRequestDeduplicator › registerPending › should add to blackout on promise rejection

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: 0

      142 |       await Promise.resolve();
      143 |
    > 144 |       expect(deduplicator.errorBlackouts.size).toBe(1);
          |                                                ^
      145 |     });
      146 |   });
      147 |

      at toBe (tests/unit/domain/ai/AIRequestDeduplicator.test.js:144:48)
      at Generator.call (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)
      at asyncGeneratorStep (tests/unit/domain/ai/AIRequestDeduplicator.test.js:2:1)

 FAIL  tests/unit/application/commands/conversation/ResetCommand.test.js
  ● ResetCommand › execute › should reset conversation successfully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "✅ Conversation with **Test Personality** has been reset"
    Received: {"embeds": [{"color": 5025616, "description": "Your conversation with **Test Personality** has been reset in this channel.", "fields": [{"inline": true, "name": "Personality", "value": "Test Personality"}, {"inline": true, "name": "Channel", "value": "<#987654321>"}, {"inline": false, "name": "What happened?", "value": "All conversation history and context has been cleared. The next message will start a fresh conversation."}], "footer": {"text": "Using new DDD system"}, "thumbnail": undefined, "timestamp": "2025-06-19T07:08:38.266Z", "title": "✅ Conversation Reset"}]}

    Number of calls: 1

      82 |       );
      83 |
    > 84 |       expect(mockContext.respond).toHaveBeenCalledWith(
         |                                   ^
      85 |         expect.stringContaining('✅ Conversation with **Test Personality** has been reset')
      86 |       );
      87 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:84:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

  ● ResetCommand › execute › should show new system indicator when feature flag enabled

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Using new DDD system"
    Received: {"embeds": [{"color": 5025616, "description": "Your conversation with **Test Personality** has been reset in this channel.", "fields": [{"inline": true, "name": "Personality", "value": "Test Personality"}, {"inline": true, "name": "Channel", "value": "<#987654321>"}, {"inline": false, "name": "What happened?", "value": "All conversation history and context has been cleared. The next message will start a fresh conversation."}], "footer": {"text": "Using new DDD system"}, "thumbnail": undefined, "timestamp": "2025-06-19T07:08:38.282Z", "title": "✅ Conversation Reset"}]}

    Number of calls: 1

      90 |       await command.execute(mockContext);
      91 |
    > 92 |       expect(mockContext.respond).toHaveBeenCalledWith(
         |                                   ^
      93 |         expect.stringContaining('Using new DDD system')
      94 |       );
      95 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:92:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

  ● ResetCommand › execute › should handle missing personality name

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "You need to provide a personality name"
    Received: {"embeds": [{"color": 16007990, "description": "Please provide a personality name or alias to reset.", "fields": [{"inline": false, "name": "Usage", "value": "`!tz reset <personality>`"}, {"inline": false, "name": "Examples", "value": "• `!tz reset Claude`
    • `!tz reset aria`
    • `!tz reset \"bambi prime\"`"}, {"inline": false, "name": "What does reset do?", "value": "Clears all conversation history with the personality in this channel, starting fresh."}], "footer": {"text": "Use the list command to see available personalities"}, "title": "❌ Missing Personality Name"}]}

    Number of calls: 1

      100 |       await command.execute(mockContext);
      101 |
    > 102 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      103 |         expect.stringContaining('You need to provide a personality name')
      104 |       );
      105 |       expect(mockPersonalityService.getPersonality).not.toHaveBeenCalled();

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:102:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

  ● ResetCommand › execute › should handle personality not found

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Personality \"testpersonality\" not found"
    Received: {"embeds": [{"color": 16007990, "description": "Could not find a personality named **testpersonality**.", "fields": [{"inline": true, "name": "Search term", "value": "testpersonality"}, {"inline": false, "name": "What to do", "value": "• Check the spelling and try again
    • Use `!tz list` to see available personalities
    • Personality names are case-insensitive"}], "timestamp": "2025-06-19T07:08:38.295Z", "title": "❌ Personality Not Found"}]}

    Number of calls: 1

      120 |       await command.execute(mockContext);
      121 |
    > 122 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      123 |         expect.stringContaining('Personality "testpersonality" not found')
      124 |       );
      125 |       expect(mockConversationManager.clearConversation).not.toHaveBeenCalled();

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:122:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

  ● ResetCommand › execute › should handle no active conversation

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "No active conversation found"
    Received: {"embeds": [{"color": 16007990, "description": "No active conversation found with **Test Personality** in this channel.", "fields": [{"inline": false, "name": "How to start a conversation", "value": "• Mention @testpersonality to start chatting
    • Reply to a personality message
    • Use activate command for channel-wide responses"}], "timestamp": "2025-06-19T07:08:38.305Z", "title": "❌ No Active Conversation"}]}

    Number of calls: 1

      131 |       await command.execute(mockContext);
      132 |
    > 133 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      134 |         expect.stringContaining('No active conversation found')
      135 |       );
      136 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:133:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

  ● ResetCommand › execute › should handle missing personality service

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "❌ An error occurred"
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while trying to reset the conversation.", "fields": [{"inline": false, "name": "Error details", "value": "PersonalityApplicationService not available"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check if the personality exists
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316918320"}, "timestamp": "2025-06-19T07:08:38.320Z", "title": "❌ Error Resetting Conversation"}]}

    Number of calls: 1

      141 |       await command.execute(mockContext);
      142 |
    > 143 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      144 |         expect.stringContaining('❌ An error occurred')
      145 |       );
      146 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:143:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

  ● ResetCommand › execute › should handle missing conversation manager

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "❌ An error occurred"
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while trying to reset the conversation.", "fields": [{"inline": false, "name": "Error details", "value": "ConversationManager not available"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check if the personality exists
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316918326"}, "timestamp": "2025-06-19T07:08:38.326Z", "title": "❌ Error Resetting Conversation"}]}

    Number of calls: 1

      151 |       await command.execute(mockContext);
      152 |
    > 153 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      154 |         expect.stringContaining('❌ An error occurred')
      155 |       );
      156 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:153:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

  ● ResetCommand › execute › should handle errors gracefully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "❌ An error occurred"
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while trying to reset the conversation.", "fields": [{"inline": false, "name": "Error details", "value": "Database error"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check if the personality exists
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316918333"}, "timestamp": "2025-06-19T07:08:38.333Z", "title": "❌ Error Resetting Conversation"}]}

    Number of calls: 1

      161 |       await command.execute(mockContext);
      162 |
    > 163 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      164 |         expect.stringContaining('❌ An error occurred')
      165 |       );
      166 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/conversation/ResetCommand.test.js:163:35)
      at Generator.call (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ResetCommand.test.js:2:1)

 FAIL  tests/unit/application/commands/conversation/ActivateCommand.test.js
  ● ActivateCommand › execute › should activate a personality by name

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:89:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should activate a personality by alias

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:124:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should handle multi-word personality names

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:145:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should use options.personality if provided

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:165:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should reject in DM channels

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:176:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should reject without Manage Messages permission

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:191:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should reject in non-NSFW channels

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:207:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should handle missing personality name

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:223:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should handle non-existent personality

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:241:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should handle personality service errors

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:258:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should handle activation errors

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:279:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should handle unexpected errors gracefully

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:299:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should not include thumbnail if profileUrl is missing

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:322:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

  ● ActivateCommand › execute › should include thumbnail if profileUrl exists

    TypeError: Cannot read properties of undefined (reading 'personalityApplicationService')

      40 |   return async function execute(context) {
      41 |     const { args, options } = context;
    > 42 |     const personalityService = context.dependencies.personalityApplicationService;
         |                                                     ^
      43 |     const conversationManager = context.dependencies.conversationManager;
      44 |
      45 |     logger.info(`[ActivateCommand] Executing for channel ${context.getChannelId()}`);

      at personalityApplicationService (src/application/commands/conversation/ActivateCommand.js:42:53)
      at Generator.call (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/ActivateCommand.js:2:1)
      at _next (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/ActivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/ActivateCommand.js:40:32)
      at execute (tests/unit/application/commands/conversation/ActivateCommand.test.js:340:21)
      at Generator.call (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/ActivateCommand.test.js:2:1)

 FAIL  tests/unit/application/commands/conversation/DeactivateCommand.test.js
  ● DeactivateCommand › execute › should deactivate an active personality

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:73:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should reject in DM channels

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:102:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should reject without Manage Messages permission

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:116:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should handle no active personality

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:131:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should handle deactivation errors

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:149:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should handle unexpected errors gracefully

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:168:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should log successful deactivation

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:186:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should include timestamp in embed

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:200:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

  ● DeactivateCommand › execute › should handle personalities with special characters in names

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      29 | function createExecutor(dependencies) {
      30 |   return async function execute(context) {
    > 31 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      32 |
      33 |     logger.info(`[DeactivateCommand] Executing for channel ${context.getChannelId()}`);
      34 |

      at conversationManager (src/application/commands/conversation/DeactivateCommand.js:31:54)
      at Generator.call (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at _next (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/DeactivateCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/DeactivateCommand.js:30:32)
      at execute (tests/unit/application/commands/conversation/DeactivateCommand.test.js:214:21)
      at Generator.call (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/DeactivateCommand.test.js:2:1)

 FAIL  tests/unit/adapters/ai/HttpAIServiceAdapter.test.js
  ● HttpAIServiceAdapter › constructor › should initialize with provided config

    expect(received).toBe(expected) // Object.is equality

    Expected: "https://api.example.com"
    Received: undefined

      53 |   describe('constructor', () => {
      54 |     it('should initialize with provided config', () => {
    > 55 |       expect(adapter.baseUrl).toBe('https://api.example.com');
         |                               ^
      56 |       expect(adapter.headers).toEqual({ 'X-API-Key': 'test-key' });
      57 |       expect(adapter.timeout).toBe(5000);
      58 |       expect(adapter.maxRetries).toBe(2);

      at Object.toBe (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:55:31)

  ● HttpAIServiceAdapter › constructor › should throw error when no base URL provided

    expect(received).toThrow(expected)

    Expected substring: "AI service base URL is required"

    Received function did not throw

      64 |       delete process.env.SERVICE_API_BASE_URL;
      65 |
    > 66 |       expect(() => new HttpAIServiceAdapter()).toThrow('AI service base URL is required');
         |                                                ^
      67 |     });
      68 |
      69 |     it('should use environment variable for base URL', () => {

      at Object.toThrow (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:66:48)

  ● HttpAIServiceAdapter › constructor › should use environment variable for base URL

    expect(received).toBe(expected) // Object.is equality

    Expected: "https://default.example.com"
    Received: undefined

      72 |
      73 |       const defaultAdapter = new HttpAIServiceAdapter();
    > 74 |       expect(defaultAdapter.baseUrl).toBe('https://default.example.com');
         |                                      ^
      75 |       expect(defaultAdapter.timeout).toBe(30000);
      76 |       expect(defaultAdapter.maxRetries).toBe(3);
      77 |       expect(defaultAdapter.retryDelay).toBe(1000);

      at Object.toBe (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:74:38)

  ● HttpAIServiceAdapter › checkHealth › should return true when health check succeeds

    TypeError: adapter.checkHealth is not a function

      90 |       });
      91 |
    > 92 |       const result = await adapter.checkHealth();
         |                                    ^
      93 |
      94 |       expect(result).toBe(true);
      95 |       expect(mockFetch).toHaveBeenCalledWith(

      at checkHealth (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:92:36)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)

  ● HttpAIServiceAdapter › checkHealth › should return false when health check fails

    TypeError: adapter.checkHealth is not a function

      105 |       mockFetch.mockRejectedValue(new Error('Network error'));
      106 |
    > 107 |       const result = await adapter.checkHealth();
          |                                    ^
      108 |
      109 |       expect(result).toBe(false);
      110 |       expect(logger.warn).toHaveBeenCalled();

      at checkHealth (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:107:36)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)

  ● HttpAIServiceAdapter › checkHealth › should handle timeout with AbortController

    TypeError: adapter.checkHealth is not a function

      117 |       mockFetch.mockRejectedValue(abortError);
      118 |
    > 119 |       const result = await adapter.checkHealth();
          |                                    ^
      120 |
      121 |       expect(result).toBe(false);
      122 |       expect(logger.warn).toHaveBeenCalledWith(

      at checkHealth (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:119:36)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)

  ● HttpAIServiceAdapter › sendRequest › should successfully generate content

    expect(received).toBeInstanceOf(expected)

    Expected constructor: AIContent
    Received constructor: Object

      164 |       const result = await adapter.sendRequest(mockRequest);
      165 |
    > 166 |       expect(result).toBeInstanceOf(AIContent);
          |                      ^
      167 |       expect(result.getText()).toBe('Hello from AI!');
      168 |       expect(mockFetch).toHaveBeenCalledWith(
      169 |         'https://api.example.com/v1/chat/completions',

      at toBeInstanceOf (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:166:22)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)

  ● HttpAIServiceAdapter › sendRequest › should validate AIRequest input

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      180 |
      181 |     it('should validate AIRequest input', async () => {
    > 182 |       await expect(adapter.sendRequest('not-a-request'))
          |             ^
      183 |         .rejects.toThrow('Request must be an instance of AIRequest');
      184 |
      185 |       await expect(adapter.sendRequest(null))

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:182:13)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)

  ● HttpAIServiceAdapter › sendRequest › should handle network errors with retry

    expect(received).toBeInstanceOf(expected)

    Expected constructor: AIContent
    Received constructor: Object

      203 |       const result = await resultPromise;
      204 |
    > 205 |       expect(result).toBeInstanceOf(AIContent);
          |                      ^
      206 |       expect(result.getText()).toBe('Success after retry');
      207 |
      208 |       // Verify retry was attempted

      at toBeInstanceOf (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:205:22)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)

  ● HttpAIServiceAdapter › sendRequest › should not retry on client errors

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      221 |       });
      222 |
    > 223 |       await expect(adapter.sendRequest(mockRequest))
          |             ^
      224 |         .rejects.toThrow('Invalid request to AI service');
      225 |
      226 |       // Should only call once (no retry)

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:223:13)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:2:1)

  ● HttpAIServiceAdapter › getStats › should return adapter statistics

    TypeError: adapter.getStats is not a function

      236 |       adapter._lastHealthCheck = true;
      237 |
    > 238 |       const stats = adapter.getStats();
          |                             ^
      239 |
      240 |       expect(stats).toEqual({
      241 |         baseUrl: 'https://api.example.com',

      at Object.getStats (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:238:29)

  ● HttpAIServiceAdapter › error transformation › should transform 401 errors

    TypeError: adapter._transformError is not a function

      255 |       error.response = { status: 401 };
      256 |
    > 257 |       const transformed = adapter._transformError(error);
          |                                   ^
      258 |       expect(transformed.message).toBe('AI service authentication failed');
      259 |     });
      260 |

      at Object._transformError (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:257:35)

  ● HttpAIServiceAdapter › error transformation › should transform 429 errors

    TypeError: adapter._transformError is not a function

      263 |       error.response = { status: 429 };
      264 |
    > 265 |       const transformed = adapter._transformError(error);
          |                                   ^
      266 |       expect(transformed.message).toBe('AI service rate limit exceeded');
      267 |     });
      268 |

      at Object._transformError (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:265:35)

  ● HttpAIServiceAdapter › error transformation › should transform timeout errors

    TypeError: adapter._transformError is not a function

      271 |       error.name = 'AbortError';
      272 |
    > 273 |       const transformed = adapter._transformError(error);
          |                                   ^
      274 |       expect(transformed.message).toBe('AI service request timed out');
      275 |     });
      276 |

      at Object._transformError (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:273:35)

  ● HttpAIServiceAdapter › error transformation › should return original error if cannot transform

    TypeError: adapter._transformError is not a function

      278 |       const error = new Error('Unknown error');
      279 |
    > 280 |       const transformed = adapter._transformError(error);
          |                                   ^
      281 |       expect(transformed).toBe(error);
      282 |     });
      283 |   });

      at Object._transformError (tests/unit/adapters/ai/HttpAIServiceAdapter.test.js:280:35)

 FAIL  tests/unit/domain/ai/index.test.js
  ● AI Domain Index › domain boundary › should provide complete public API

    expect(received).toHaveLength(expected)

    Expected length: 14
    Received length: 15
    Received array:  ["AIRequest", "AIRequestId", "AIContent", "AIModel", "AIService", "AIRequestDeduplicator", "AIRequestRepository", "AIRequestCreated", "AIRequestSent", "AIResponseReceived", …]

      140 |       }
      141 |
    > 142 |       expect(exportedKeys).toHaveLength(expectedKeys.length);
          |                            ^
      143 |     });
      144 |   });
      145 | });

      at Object.toHaveLength (tests/unit/domain/ai/index.test.js:142:28)

 FAIL  tests/unit/handlers/messageHandler.test.js
  ● messageHandler › handleMentions › should handle multi-word mentions

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

      {"author": {"bot": false, "id": "author-123", "tag": "User#1234", "username": "User"}, "channel": {"id": "channel-123", "isDMBased": [Function isDMBased], "send": [Function mockConstructor]}, "content": "@Test Personality Hello there", "id": "message-123", "reference": null, "reply": [Function mockConstructor], "webhookId": null},
    - Object {
    -   "displayName": "TestPersonality",
    -   "fullName": "test-personality",
    + Promise {
    +   Symbol(async_id_symbol): 29090,
    +   Symbol(trigger_async_id_symbol): 29082,
      },
      "Test Personality",
      {"user": {"id": "client-123"}},
      [Function handlePersonalityInteraction],

    Number of calls: 1

      540 |
      541 |       // For server channels (default mock), should use delayed processing
    > 542 |       expect(messageTrackerHandler.delayedProcessing).toHaveBeenCalledWith(
          |                                                       ^
      543 |         multiWordMentionMessage,
      544 |         mockPersonality,
      545 |         'Test Personality',

      at toHaveBeenCalledWith (tests/unit/handlers/messageHandler.test.js:542:55)
      at Generator.call (tests/unit/handlers/messageHandler.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.test.js:2:1)

  ● messageHandler › handleMentions › should prioritize longest multi-word mentions

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

      {"author": {"bot": false, "id": "author-123", "tag": "User#1234", "username": "User"}, "channel": {"id": "channel-123", "isDMBased": [Function isDMBased], "send": [Function mockConstructor]}, "content": "@Test Personality Prime Hello there", "id": "message-123", "reference": null, "reply": [Function mockConstructor], "webhookId": null},
    - Object {
    -   "displayName": "Test Personality Prime",
    -   "fullName": "test-personality-prime",
    + Promise {
    +   Symbol(async_id_symbol): 29367,
    +   Symbol(trigger_async_id_symbol): 29359,
      },
      "Test Personality Prime",
      {"user": {"id": "client-123"}},
      [Function handlePersonalityInteraction],

    Number of calls: 1

      592 |
      593 |       // For server channels, should use delayed processing with the longest match
    > 594 |       expect(messageTrackerHandler.delayedProcessing).toHaveBeenCalledWith(
          |                                                       ^
      595 |         complexMentionMessage,
      596 |         testPersonalityPrime,
      597 |         'Test Personality Prime',

      at toHaveBeenCalledWith (tests/unit/handlers/messageHandler.test.js:594:55)
      at Generator.call (tests/unit/handlers/messageHandler.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.test.js:2:1)

 FAIL  tests/unit/application/services/PersonalityApplicationService.test.js
  ● PersonalityApplicationService › constructor › should require personalityRepository

    expect(received).toThrow(expected)

    Expected substring: "PersonalityRepository is required"

    Received function did not throw

      110 |         aiService: mockAiService,
      111 |         authenticationRepository: mockAuthenticationRepository
    > 112 |       })).toThrow('PersonalityRepository is required');
          |           ^
      113 |     });
      114 |
      115 |     it('should require aiService', () => {

      at Object.toThrow (tests/unit/application/services/PersonalityApplicationService.test.js:112:11)

  ● PersonalityApplicationService › constructor › should require aiService

    expect(received).toThrow(expected)

    Expected substring: "AIService is required"

    Received function did not throw

      117 |         personalityRepository: mockPersonalityRepository,
      118 |         authenticationRepository: mockAuthenticationRepository
    > 119 |       })).toThrow('AIService is required');
          |           ^
      120 |     });
      121 |
      122 |     it('should require authenticationRepository', () => {

      at Object.toThrow (tests/unit/application/services/PersonalityApplicationService.test.js:119:11)

  ● PersonalityApplicationService › constructor › should require authenticationRepository

    expect(received).toThrow(expected)

    Expected substring: "AuthenticationRepository is required"

    Received function did not throw

      124 |         personalityRepository: mockPersonalityRepository,
      125 |         aiService: mockAiService
    > 126 |       })).toThrow('AuthenticationRepository is required');
          |           ^
      127 |     });
      128 |
      129 |     it('should use default event bus if not provided', () => {

      at Object.toThrow (tests/unit/application/services/PersonalityApplicationService.test.js:126:11)

  ● PersonalityApplicationService › constructor › should use default event bus if not provided

    expect(received).toBeDefined()

    Received: undefined

      134 |       });
      135 |
    > 136 |       expect(serviceWithDefaultBus.eventBus).toBeDefined();
          |                                              ^
      137 |       expect(serviceWithDefaultBus.eventBus.publish).toBeDefined();
      138 |       expect(typeof serviceWithDefaultBus.eventBus.publish).toBe('function');
      139 |     });

      at Object.toBeDefined (tests/unit/application/services/PersonalityApplicationService.test.js:136:46)

  ● PersonalityApplicationService › registerPersonality › local mode › should successfully register a new local personality

    expect(received).toBeInstanceOf(expected)

    Expected constructor: Personality
    Received constructor: Object

      158 |         const result = await service.registerPersonality(validLocalCommand);
      159 |
    > 160 |         expect(result).toBeInstanceOf(Personality);
          |                        ^
      161 |         expect(result.profile.name).toBe('TestBot');
      162 |         expect(result.profile.mode).toBe('local');
      163 |         expect(result.profile.prompt).toBe('You are a helpful test bot');

      at toBeInstanceOf (tests/unit/application/services/PersonalityApplicationService.test.js:160:24)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › registerPersonality › local mode › should reject local personality without prompt

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      173 |         delete invalidCommand.prompt;
      174 |
    > 175 |         await expect(service.registerPersonality(invalidCommand))
          |               ^
      176 |           .rejects.toThrow('Local personalities require prompt and modelPath');
      177 |       });
      178 |     });

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/application/services/PersonalityApplicationService.test.js:175:15)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › registerPersonality › external mode › should successfully register a new external personality

    expect(received).toBeInstanceOf(expected)

    Expected constructor: Personality
    Received constructor: Object

      192 |         const result = await service.registerPersonality(validExternalCommand);
      193 |
    > 194 |         expect(result).toBeInstanceOf(Personality);
          |                        ^
      195 |         expect(result.profile.name).toBe('TestBot');
      196 |         expect(result.profile.mode).toBe('external');
      197 |         expect(result.profile.prompt).toBeNull();

      at toBeInstanceOf (tests/unit/application/services/PersonalityApplicationService.test.js:194:24)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › registerPersonality › external mode › should default to external mode when not specified

    TypeError: Cannot read properties of undefined (reading 'mode')

      212 |         const result = await service.registerPersonality(commandWithoutMode);
      213 |
    > 214 |         expect(result.profile.mode).toBe('external');
          |                               ^
      215 |       });
      216 |     });
      217 |

      at mode (tests/unit/application/services/PersonalityApplicationService.test.js:214:31)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › registerPersonality › should reject if personality name already exists

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      240 |       };
      241 |
    > 242 |       await expect(service.registerPersonality(command))
          |             ^
      243 |         .rejects.toThrow('Personality "TestBot" already exists');
      244 |
      245 |       expect(mockPersonalityRepository.save).not.toHaveBeenCalled();

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/application/services/PersonalityApplicationService.test.js:242:13)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › registerPersonality › should reject if alias conflicts with existing personality

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      275 |       };
      276 |
    > 277 |       await expect(service.registerPersonality(command))
          |             ^
      278 |         .rejects.toThrow('Alias "TestB" is already in use by OtherBot');
      279 |     });
      280 |

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/application/services/PersonalityApplicationService.test.js:277:13)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › registerPersonality › should handle AI service errors gracefully

    expect(received).toBeInstanceOf(expected)

    Expected constructor: Personality
    Received constructor: Object

      295 |
      296 |       // Should still create personality with default model capabilities
    > 297 |       expect(result).toBeInstanceOf(Personality);
          |                      ^
      298 |       expect(result.model.capabilities.maxTokens).toBe(4096);
      299 |       expect(mockPersonalityRepository.save).toHaveBeenCalled();
      300 |     });

      at toBeInstanceOf (tests/unit/application/services/PersonalityApplicationService.test.js:297:22)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › registerPersonality › should work without aliases

    expect(received).toBeInstanceOf(expected)

    Expected constructor: Personality
    Received constructor: Object

      311 |       const result = await service.registerPersonality(command);
      312 |
    > 313 |       expect(result).toBeInstanceOf(Personality);
          |                      ^
      314 |       expect(result.aliases).toHaveLength(0);
      315 |     });
      316 |   });

      at toBeInstanceOf (tests/unit/application/services/PersonalityApplicationService.test.js:313:22)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › updatePersonalityProfile › should update prompt successfully

    TypeError: service.updatePersonalityProfile is not a function

      338 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      339 |
    > 340 |       const result = await service.updatePersonalityProfile({
          |                                    ^
      341 |         personalityName: 'TestBot',
      342 |         requesterId: '123456789012345678',
      343 |         prompt: 'Updated prompt'

      at updatePersonalityProfile (tests/unit/application/services/PersonalityApplicationService.test.js:340:36)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › updatePersonalityProfile › should update model path and resolve new model

    TypeError: service.updatePersonalityProfile is not a function

      352 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      353 |
    > 354 |       const result = await service.updatePersonalityProfile({
          |                                    ^
      355 |         personalityName: 'TestBot',
      356 |         requesterId: '123456789012345678',
      357 |         modelPath: '/models/gpt-4'

      at updatePersonalityProfile (tests/unit/application/services/PersonalityApplicationService.test.js:354:36)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › updatePersonalityProfile › should update multiple fields at once

    TypeError: service.updatePersonalityProfile is not a function

      366 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      367 |
    > 368 |       const result = await service.updatePersonalityProfile({
          |                                    ^
      369 |         personalityName: 'TestBot',
      370 |         requesterId: '123456789012345678',
      371 |         prompt: 'New prompt',

      at updatePersonalityProfile (tests/unit/application/services/PersonalityApplicationService.test.js:368:36)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › updatePersonalityProfile › should reject if personality not found

    TypeError: service.updatePersonalityProfile is not a function

      382 |       mockPersonalityRepository.findByName.mockResolvedValue(null);
      383 |
    > 384 |       await expect(service.updatePersonalityProfile({
          |                            ^
      385 |         personalityName: 'NonExistent',
      386 |         requesterId: '123456789012345678',
      387 |         prompt: 'New prompt'

      at updatePersonalityProfile (tests/unit/application/services/PersonalityApplicationService.test.js:384:28)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › updatePersonalityProfile › should reject if requester is not the owner

    TypeError: service.updatePersonalityProfile is not a function

      392 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      393 |
    > 394 |       await expect(service.updatePersonalityProfile({
          |                            ^
      395 |         personalityName: 'TestBot',
      396 |         requesterId: '999999999999999999', // Different user
      397 |         prompt: 'New prompt'

      at updatePersonalityProfile (tests/unit/application/services/PersonalityApplicationService.test.js:394:28)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › addAlias › should add alias successfully

    expect(received).toContainEqual(expected) // deep equality

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      428 |       });
      429 |
    > 430 |       expect(result.aliases).toContainEqual(expect.objectContaining({ name: 'NewAlias' }));
          |                              ^
      431 |       expect(mockPersonalityRepository.save).toHaveBeenCalled();
      432 |       expect(mockEventBus.publish).toHaveBeenCalled();
      433 |     });

      at toContainEqual (tests/unit/application/services/PersonalityApplicationService.test.js:430:30)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › addAlias › should reject if personality not found

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      436 |       mockPersonalityRepository.findByName.mockResolvedValue(null);
      437 |
    > 438 |       await expect(service.addAlias({
          |             ^
      439 |         personalityName: 'NonExistent',
      440 |         alias: 'NewAlias',
      441 |         requesterId: '123456789012345678'

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/application/services/PersonalityApplicationService.test.js:438:13)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › addAlias › should reject if requester is not the owner

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      446 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      447 |
    > 448 |       await expect(service.addAlias({
          |             ^
      449 |         personalityName: 'TestBot',
      450 |         alias: 'NewAlias',
      451 |         requesterId: '999999999999999999'

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/application/services/PersonalityApplicationService.test.js:448:13)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › addAlias › should reassign alias if already in use by another personality

    expect(received).toContainEqual(expected) // deep equality

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      473 |
      474 |       // Verify alias was added to new personality
    > 475 |       expect(result.aliases).toContainEqual(expect.objectContaining({ value: 'takenalias' }));
          |                              ^
      476 |
      477 |       // Verify both personalities were saved
      478 |       expect(mockPersonalityRepository.save).toHaveBeenCalledTimes(2);

      at toContainEqual (tests/unit/application/services/PersonalityApplicationService.test.js:475:30)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › addAlias › should no-op if alias already points to same personality

    expect(received).toBe(expected) // Object.is equality

    - Expected  - 38
    + Received  +  1

    - Object {
    -   "aliases": Array [
    -     Object {
    -       "original": "ExistingAlias",
    -       "value": "existingalias",
    -     },
    -   ],
    -   "createdAt": "2025-06-19T07:08:40.930Z",
    -   "id": "personality-mc31i3qa-vqkb0eu",
    -   "model": Object {
    -     "capabilities": Object {
    -       "maxTokens": 4096,
    -       "supportsAudio": false,
    -       "supportsImages": false,
    -       "temperature": 0.7,
    -     },
    -     "name": "gpt-4",
    -     "path": "/model",
    -   },
    -   "ownerId": "123456789012345678",
    -   "personalityId": "personality-mc31i3qa-vqkb0eu",
    -   "profile": Object {
    -     "avatarUrl": null,
    -     "displayName": "TestBot",
    -     "errorMessage": null,
    -     "jailbreak": null,
    -     "maxWordCount": 2000,
    -     "mode": "local",
    -     "modelPath": "/model",
    -     "name": "TestBot",
    -     "prompt": "Test prompt",
    -     "temperature": 1,
    -     "voiceConfig": null,
    -   },
    -   "removed": false,
    -   "updatedAt": "2025-06-19T07:08:40.930Z",
    -   "version": 2,
    - }
    + Object {}

      496 |       });
      497 |
    > 498 |       expect(result).toBe(existingPersonality);
          |                      ^
      499 |       // Should not save when alias already exists for same personality
      500 |       expect(mockPersonalityRepository.save).not.toHaveBeenCalled();
      501 |     });

      at toBe (tests/unit/application/services/PersonalityApplicationService.test.js:498:22)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › removeAlias › should remove alias successfully

    TypeError: service.removeAlias is not a function

      520 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      521 |
    > 522 |       const result = await service.removeAlias({
          |                                    ^
      523 |         personalityName: 'TestBot',
      524 |         alias: 'TB',
      525 |         requesterId: '123456789012345678'

      at removeAlias (tests/unit/application/services/PersonalityApplicationService.test.js:522:36)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › removeAlias › should reject if requester is not the owner

    TypeError: service.removeAlias is not a function

      534 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      535 |
    > 536 |       await expect(service.removeAlias({
          |                            ^
      537 |         personalityName: 'TestBot',
      538 |         alias: 'TB',
      539 |         requesterId: '999999999999999999'

      at removeAlias (tests/unit/application/services/PersonalityApplicationService.test.js:536:28)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › removePersonality › should remove personality successfully

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      563 |       });
      564 |
    > 565 |       expect(existingPersonality.isRemoved).toBe(true);
          |                                             ^
      566 |       expect(mockPersonalityRepository.save).toHaveBeenCalled();
      567 |       expect(mockPersonalityRepository.delete).toHaveBeenCalledWith(existingPersonality.id.toString());
      568 |       expect(mockEventBus.publish).toHaveBeenCalled();

      at toBe (tests/unit/application/services/PersonalityApplicationService.test.js:565:45)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › removePersonality › should reject if personality not found

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: true

      572 |       mockPersonalityRepository.findByName.mockResolvedValue(null);
      573 |
    > 574 |       await expect(service.removePersonality({
          |             ^
      575 |         personalityName: 'NonExistent',
      576 |         requesterId: '123456789012345678'
      577 |       })).rejects.toThrow('Personality "NonExistent" not found');

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/application/services/PersonalityApplicationService.test.js:574:13)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › removePersonality › should reject if requester is not the owner

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: true

      581 |       mockPersonalityRepository.findByName.mockResolvedValue(existingPersonality);
      582 |
    > 583 |       await expect(service.removePersonality({
          |             ^
      584 |         personalityName: 'TestBot',
      585 |         requesterId: '999999999999999999'
      586 |       })).rejects.toThrow('Only the owner can remove a personality');

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/application/services/PersonalityApplicationService.test.js:583:13)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonality › should find personality by name

    expect(received).toBe(expected) // Object.is equality

    Expected: {"aliases": [{"original": "TB", "value": "tb"}], "createdAt": "2025-06-19T07:08:40.965Z", "id": "personality-mc31i3r9-z5amshc", "model": {"capabilities": {"maxTokens": 4096, "supportsAudio": false, "supportsImages": false, "temperature": 0.7}, "name": "gpt-4", "path": "/model"}, "ownerId": "123456789012345678", "personalityId": "personality-mc31i3r9-z5amshc", "profile": {"avatarUrl": null, "displayName": "TestBot", "errorMessage": null, "jailbreak": null, "maxWordCount": 1000, "mode": "local", "modelPath": "/model", "name": "TestBot", "prompt": "Test prompt", "temperature": 1, "voiceConfig": null}, "removed": false, "updatedAt": "2025-06-19T07:08:40.965Z", "version": 2}
    Received: null

      606 |       const result = await service.getPersonality('TestBot');
      607 |
    > 608 |       expect(result).toBe(personality);
          |                      ^
      609 |       expect(mockPersonalityRepository.findByName).toHaveBeenCalledWith('TestBot');
      610 |       expect(mockPersonalityRepository.findByAlias).not.toHaveBeenCalled();
      611 |     });

      at toBe (tests/unit/application/services/PersonalityApplicationService.test.js:608:22)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonality › should find personality by alias if not found by name

    expect(received).toBe(expected) // Object.is equality

    Expected: {"aliases": [{"original": "TB", "value": "tb"}], "createdAt": "2025-06-19T07:08:40.973Z", "id": "personality-mc31i3rh-q0r7nd8", "model": {"capabilities": {"maxTokens": 4096, "supportsAudio": false, "supportsImages": false, "temperature": 0.7}, "name": "gpt-4", "path": "/model"}, "ownerId": "123456789012345678", "personalityId": "personality-mc31i3rh-q0r7nd8", "profile": {"avatarUrl": null, "displayName": "TestBot", "errorMessage": null, "jailbreak": null, "maxWordCount": 1000, "mode": "local", "modelPath": "/model", "name": "TestBot", "prompt": "Test prompt", "temperature": 1, "voiceConfig": null}, "removed": false, "updatedAt": "2025-06-19T07:08:40.973Z", "version": 2}
    Received: null

      617 |       const result = await service.getPersonality('TB');
      618 |
    > 619 |       expect(result).toBe(personality);
          |                      ^
      620 |       expect(mockPersonalityRepository.findByAlias).toHaveBeenCalledWith('TB');
      621 |     });
      622 |

      at toBe (tests/unit/application/services/PersonalityApplicationService.test.js:619:22)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › listPersonalities › should return all personalities

    TypeError: service.listPersonalities is not a function

      650 |       mockPersonalityRepository.findAll.mockResolvedValue(personalities);
      651 |
    > 652 |       const result = await service.listPersonalities();
          |                                    ^
      653 |
      654 |       expect(result).toEqual(personalities);
      655 |       expect(mockPersonalityRepository.findAll).toHaveBeenCalled();

      at listPersonalities (tests/unit/application/services/PersonalityApplicationService.test.js:652:36)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › listPersonalitiesByOwner › should return personalities for specific owner

    expect(received).toEqual(expected) // deep equality

    - Expected  - 68
    + Received  +  1

    - Array [
    -   Object {
    -     "aliases": Array [],
    -     "createdAt": "2025-06-19T07:08:40.988Z",
    -     "id": "personality-mc31i3rw-7w5e7aj",
    -     "model": Object {
    -       "capabilities": Object {
    -         "maxTokens": 4096,
    -         "supportsAudio": false,
    -         "supportsImages": false,
    -         "temperature": 0.7,
    -       },
    -       "name": "gpt-4",
    -       "path": "/model",
    -     },
    -     "ownerId": "123456789012345678",
    -     "personalityId": "personality-mc31i3rw-7w5e7aj",
    -     "profile": Object {
    -       "avatarUrl": null,
    -       "displayName": "Bot1",
    -       "errorMessage": null,
    -       "jailbreak": null,
    -       "maxWordCount": 1000,
    -       "mode": "local",
    -       "modelPath": "/model",
    -       "name": "Bot1",
    -       "prompt": "Prompt1",
    -       "temperature": 1,
    -       "voiceConfig": null,
    -     },
    -     "removed": false,
    -     "updatedAt": "2025-06-19T07:08:40.988Z",
    -     "version": 1,
    -   },
    -   Object {
    -     "aliases": Array [],
    -     "createdAt": "2025-06-19T07:08:40.988Z",
    -     "id": "personality-mc31i3rw-z1kmiol",
    -     "model": Object {
    -       "capabilities": Object {
    -         "maxTokens": 4096,
    -         "supportsAudio": false,
    -         "supportsImages": false,
    -         "temperature": 0.7,
    -       },
    -       "name": "gpt-4",
    -       "path": "/model",
    -     },
    -     "ownerId": "123456789012345678",
    -     "personalityId": "personality-mc31i3rw-z1kmiol",
    -     "profile": Object {
    -       "avatarUrl": null,
    -       "displayName": "Bot2",
    -       "errorMessage": null,
    -       "jailbreak": null,
    -       "maxWordCount": 1000,
    -       "mode": "local",
    -       "modelPath": "/model",
    -       "name": "Bot2",
    -       "prompt": "Prompt2",
    -       "temperature": 1,
    -       "voiceConfig": null,
    -     },
    -     "removed": false,
    -     "updatedAt": "2025-06-19T07:08:40.988Z",
    -     "version": 1,
    -   },
    - ]
    + Array []

      679 |       const result = await service.listPersonalitiesByOwner(ownerId);
      680 |
    > 681 |       expect(result).toEqual(personalities);
          |                      ^
      682 |       expect(mockPersonalityRepository.findByOwner).toHaveBeenCalledWith(expect.objectContaining({
      683 |         value: ownerId
      684 |       }));

      at toEqual (tests/unit/application/services/PersonalityApplicationService.test.js:681:22)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › checkPermission › should grant permission to owner

    TypeError: service.checkPermission is not a function

      703 |       mockPersonalityRepository.findByAlias.mockResolvedValue(null);
      704 |
    > 705 |       const hasPermission = await service.checkPermission({
          |                                           ^
      706 |         userId: ownerId,
      707 |         personalityName: 'TestBot'
      708 |       });

      at checkPermission (tests/unit/application/services/PersonalityApplicationService.test.js:705:43)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › checkPermission › should grant permission to authenticated user

    TypeError: service.checkPermission is not a function

      722 |       mockAuthenticationRepository.findByUserId.mockResolvedValue(mockUserAuth);
      723 |
    > 724 |       const hasPermission = await service.checkPermission({
          |                                           ^
      725 |         userId: otherUserId,
      726 |         personalityName: 'TestBot'
      727 |       });

      at checkPermission (tests/unit/application/services/PersonalityApplicationService.test.js:724:43)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › checkPermission › should deny permission to unauthenticated user

    TypeError: service.checkPermission is not a function

      741 |       mockAuthenticationRepository.findByUserId.mockResolvedValue(mockUserAuth);
      742 |
    > 743 |       const hasPermission = await service.checkPermission({
          |                                           ^
      744 |         userId: otherUserId,
      745 |         personalityName: 'TestBot'
      746 |       });

      at checkPermission (tests/unit/application/services/PersonalityApplicationService.test.js:743:43)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › checkPermission › should deny permission if personality not found

    TypeError: service.checkPermission is not a function

      753 |       mockPersonalityRepository.findByAlias.mockResolvedValue(null);
      754 |
    > 755 |       const hasPermission = await service.checkPermission({
          |                                           ^
      756 |         userId: ownerId,
      757 |         personalityName: 'NonExistent'
      758 |       });

      at checkPermission (tests/unit/application/services/PersonalityApplicationService.test.js:755:43)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › checkPermission › should deny permission if no user auth found

    TypeError: service.checkPermission is not a function

      767 |       mockAuthenticationRepository.findByUserId.mockResolvedValue(null);
      768 |
    > 769 |       const hasPermission = await service.checkPermission({
          |                                           ^
      770 |         userId: otherUserId,
      771 |         personalityName: 'TestBot'
      772 |       });

      at checkPermission (tests/unit/application/services/PersonalityApplicationService.test.js:769:43)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › checkPermission › should handle errors gracefully

    TypeError: service.checkPermission is not a function

      778 |       mockPersonalityRepository.findByName.mockRejectedValue(new Error('DB error'));
      779 |
    > 780 |       const hasPermission = await service.checkPermission({
          |                                           ^
      781 |         userId: ownerId,
      782 |         personalityName: 'TestBot'
      783 |       });

      at checkPermission (tests/unit/application/services/PersonalityApplicationService.test.js:780:43)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › _resolveAIModel › should create model with AI service info

    TypeError: service._resolveAIModel is not a function

      791 |       const modelPath = '/models/gpt-4';
      792 |
    > 793 |       const model = await service._resolveAIModel(modelPath);
          |                                   ^
      794 |
      795 |       expect(model).toBeInstanceOf(AIModel);
      796 |       expect(model.name).toBe('gpt-4');

      at _resolveAIModel (tests/unit/application/services/PersonalityApplicationService.test.js:793:35)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › _resolveAIModel › should create default model if AI service fails

    TypeError: service._resolveAIModel is not a function

      803 |       mockAiService.getModelInfo.mockRejectedValue(new Error('Model not found'));
      804 |
    > 805 |       const model = await service._resolveAIModel(modelPath);
          |                                   ^
      806 |
      807 |       expect(model).toBeInstanceOf(AIModel);
      808 |       expect(model.name).toBe(modelPath);

      at _resolveAIModel (tests/unit/application/services/PersonalityApplicationService.test.js:805:35)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonalityWithProfile › external mode personalities › should return personality without refresh if still fresh

    TypeError: service.getPersonalityWithProfile is not a function

      836 |         mockPersonalityRepository.findByName.mockResolvedValue(externalPersonality);
      837 |
    > 838 |         const result = await service.getPersonalityWithProfile('test-bot');
          |                                      ^
      839 |
      840 |         expect(result).toBe(externalPersonality);
      841 |         expect(mockProfileFetcher.fetchProfileInfo).not.toHaveBeenCalled();

      at getPersonalityWithProfile (tests/unit/application/services/PersonalityApplicationService.test.js:838:38)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonalityWithProfile › external mode personalities › should refresh profile from API if stale

    TypeError: service.getPersonalityWithProfile is not a function

      850 |         });
      851 |
    > 852 |         const result = await service.getPersonalityWithProfile('test-bot', '123456789012345678');
          |                                      ^
      853 |
      854 |         expect(result).toBeInstanceOf(Personality);
      855 |         expect(result.profile.displayName).toBe('Test Bot Updated');

      at getPersonalityWithProfile (tests/unit/application/services/PersonalityApplicationService.test.js:852:38)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonalityWithProfile › external mode personalities › should handle API fetch failure gracefully

    TypeError: service.getPersonalityWithProfile is not a function

      864 |         mockProfileFetcher.fetchProfileInfo.mockResolvedValue(null);
      865 |
    > 866 |         const result = await service.getPersonalityWithProfile('test-bot');
          |                                      ^
      867 |
      868 |         expect(result).toBe(externalPersonality);
      869 |         expect(result.profile.displayName).toBe('Test Bot'); // Original values unchanged

      at getPersonalityWithProfile (tests/unit/application/services/PersonalityApplicationService.test.js:866:38)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonalityWithProfile › local mode personalities › should return local personality without API refresh

    TypeError: service.getPersonalityWithProfile is not a function

      894 |         mockPersonalityRepository.findByName.mockResolvedValue(localPersonality);
      895 |
    > 896 |         const result = await service.getPersonalityWithProfile('local-bot');
          |                                      ^
      897 |
      898 |         expect(result).toBe(localPersonality);
      899 |         expect(mockProfileFetcher.fetchProfileInfo).not.toHaveBeenCalled();

      at getPersonalityWithProfile (tests/unit/application/services/PersonalityApplicationService.test.js:896:38)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonalityWithProfile › should return null if personality not found

    TypeError: service.getPersonalityWithProfile is not a function

      905 |       mockPersonalityRepository.findByName.mockResolvedValue(null);
      906 |
    > 907 |       const result = await service.getPersonalityWithProfile('non-existent');
          |                                    ^
      908 |
      909 |       expect(result).toBeNull();
      910 |       expect(mockProfileFetcher.fetchProfileInfo).not.toHaveBeenCalled();

      at getPersonalityWithProfile (tests/unit/application/services/PersonalityApplicationService.test.js:907:36)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › getPersonalityWithProfile › should handle errors and re-throw them

    TypeError: service.getPersonalityWithProfile is not a function

      914 |       mockPersonalityRepository.findByName.mockRejectedValue(new Error('Database error'));
      915 |
    > 916 |       await expect(service.getPersonalityWithProfile('test-bot'))
          |                            ^
      917 |         .rejects.toThrow('Database error');
      918 |
      919 |       expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Error getting personality'));

      at getPersonalityWithProfile (tests/unit/application/services/PersonalityApplicationService.test.js:916:28)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

  ● PersonalityApplicationService › _publishEvents › should publish all uncommitted events

    TypeError: service._publishEvents is not a function

      939 |       expect(personality.getUncommittedEvents()).toHaveLength(1);
      940 |
    > 941 |       await service._publishEvents(personality);
          |                     ^
      942 |
      943 |       expect(mockEventBus.publish).toHaveBeenCalledTimes(1);
      944 |       expect(mockEventBus.publish).toHaveBeenCalledWith(

      at _publishEvents (tests/unit/application/services/PersonalityApplicationService.test.js:941:21)
      at Generator.call (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at _next (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/services/PersonalityApplicationService.test.js:2:1)

 FAIL  tests/unit/webhookManager.helpers.test.js
  ● WebhookManager - Helper Functions › Console output management › minimizeConsoleOutput should return an empty object with structured logging

    TypeError: webhookManager.minimizeConsoleOutput is not a function

      56 |     test('minimizeConsoleOutput should return an empty object with structured logging', () => {
      57 |       // Call the function
    > 58 |       const originalFunctions = webhookManager.minimizeConsoleOutput();
         |                                                ^
      59 |
      60 |       // Verify it returns an empty object now that we're using structured logging
      61 |       expect(originalFunctions).toEqual({});

      at Object.minimizeConsoleOutput (tests/unit/webhookManager.helpers.test.js:58:48)

  ● WebhookManager - Helper Functions › Console output management › restoreConsoleOutput should be a no-op with structured logging

    TypeError: webhookManager.minimizeConsoleOutput is not a function

      72 |     test('restoreConsoleOutput should be a no-op with structured logging', () => {
      73 |       // First minimize (now returns empty object)
    > 74 |       const originalFunctions = webhookManager.minimizeConsoleOutput();
         |                                                ^
      75 |
      76 |       // Then restore (should be a no-op)
      77 |       webhookManager.restoreConsoleOutput(originalFunctions);

      at Object.minimizeConsoleOutput (tests/unit/webhookManager.helpers.test.js:74:48)

  ● WebhookManager - Helper Functions › Message ID generation › generateMessageTrackingId should create unique IDs

    TypeError: webhookManager.generateMessageTrackingId is not a function

       96 |
       97 |       // Generate IDs
    >  98 |       const id1 = webhookManager.generateMessageTrackingId(channelId);
          |                                  ^
       99 |       const id2 = webhookManager.generateMessageTrackingId(channelId);
      100 |
      101 |       // IDs should be strings

      at Object.generateMessageTrackingId (tests/unit/webhookManager.helpers.test.js:98:34)

  ● WebhookManager - Helper Functions › Error content detection › isErrorContent should identify error messages

    TypeError: webhookManager.isErrorContent is not a function

      113 |     test('isErrorContent should identify error messages', () => {
      114 |       // Test error patterns
    > 115 |       expect(webhookManager.isErrorContent("I'm having trouble connecting")).toBe(true);
          |                             ^
      116 |       expect(webhookManager.isErrorContent("ERROR_MESSAGE_PREFIX: Some error")).toBe(true);
      117 |       expect(webhookManager.isErrorContent("I'm experiencing a technical issue")).toBe(true);
      118 |       expect(webhookManager.isErrorContent("Error ID: 12345")).toBe(true);

      at Object.isErrorContent (tests/unit/webhookManager.helpers.test.js:115:29)

  ● WebhookManager - Helper Functions › Error content detection › markErrorContent should add prefix to error messages

    TypeError: webhookManager.markErrorContent is not a function

      130 |     test('markErrorContent should add prefix to error messages', () => {
      131 |       // Should add prefix to error messages
    > 132 |       expect(webhookManager.markErrorContent("I'm having trouble connecting")).toContain('ERROR_MESSAGE_PREFIX:');
          |                             ^
      133 |       expect(webhookManager.markErrorContent("technical issue")).toContain('ERROR_MESSAGE_PREFIX:');
      134 |
      135 |       // Should not modify non-error messages

      at Object.markErrorContent (tests/unit/webhookManager.helpers.test.js:132:29)

  ● WebhookManager - Helper Functions › Message preparation › prepareMessageData should format message data correctly

    TypeError: webhookManager.prepareMessageData is not a function

      153 |
      154 |       // Test with basic info
    > 155 |       const basicData = webhookManager.prepareMessageData(content, username, personality, false, threadId);
          |                                        ^
      156 |       expect(basicData.content).toBe(content);
      157 |       expect(basicData.username).toBe(username);
      158 |       expect(basicData._personality).toBe(personality); // Personality is stored internally

      at Object.prepareMessageData (tests/unit/webhookManager.helpers.test.js:155:40)

  ● WebhookManager - Helper Functions › Message chunk sending › sendMessageChunk should send message via webhook

    TypeError: webhookManager.sendMessageChunk is not a function

      182 |
      183 |       // Call the function
    > 184 |       const result = await webhookManager.sendMessageChunk(webhook, messageData, 0, 1);
          |                                           ^
      185 |
      186 |       // Verify webhook.send was called with the message data plus avatarURL
      187 |       expect(webhook.send).toHaveBeenCalledWith({

      at sendMessageChunk (tests/unit/webhookManager.helpers.test.js:184:43)
      at Generator.call (tests/unit/webhookManager.helpers.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.helpers.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.helpers.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.helpers.test.js:2:1)
      at _next (tests/unit/webhookManager.helpers.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.helpers.test.js:2:1)

  ● WebhookManager - Helper Functions › Message chunk sending › sendMessageChunk should handle errors

    TypeError: webhookManager.sendMessageChunk is not a function

      209 |
      210 |       // Call should throw, even though fallback was attempted
    > 211 |       await expect(webhookManager.sendMessageChunk(webhook, messageData, 0, 1))
          |                                   ^
      212 |         .rejects.toThrow();
      213 |
      214 |       // Verify webhook.send was called for both attempts

      at sendMessageChunk (tests/unit/webhookManager.helpers.test.js:211:35)
      at Generator.call (tests/unit/webhookManager.helpers.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.helpers.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.helpers.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.helpers.test.js:2:1)
      at _next (tests/unit/webhookManager.helpers.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.helpers.test.js:2:1)

  ● WebhookManager - Helper Functions › Virtual result creation › createVirtualResult should create a valid result object

    TypeError: webhookManager.createVirtualResult is not a function

      235 |
      236 |       // Call the function
    > 237 |       const result = webhookManager.createVirtualResult(personality, channelId);
          |                                     ^
      238 |
      239 |       // Verify structure
      240 |       expect(result).toHaveProperty('message');

      at Object.createVirtualResult (tests/unit/webhookManager.helpers.test.js:237:37)

  ● WebhookManager - Helper Functions › Virtual result creation › createVirtualResult should handle missing personality data

    TypeError: webhookManager.createVirtualResult is not a function

      251 |
      252 |       // Call with null personality
    > 253 |       const result1 = webhookManager.createVirtualResult(null, channelId);
          |                                      ^
      254 |       expect(result1).toHaveProperty('isDuplicate', true);
      255 |
      256 |       // Call with personality missing fullName

      at Object.createVirtualResult (tests/unit/webhookManager.helpers.test.js:253:38)

  ● WebhookManager - Helper Functions › Message splitting › splitByCharacterLimit should split text correctly

    TypeError: webhookManager.splitByCharacterLimit is not a function

      266 |
      267 |       // Split the text
    > 268 |       const chunks = webhookManager.splitByCharacterLimit(longText);
          |                                     ^
      269 |
      270 |       // Should be split into chunks
      271 |       expect(chunks.length).toBeGreaterThan(1);

      at Object.splitByCharacterLimit (tests/unit/webhookManager.helpers.test.js:268:37)

  ● WebhookManager - Helper Functions › Message splitting › processSentence should handle sentences correctly

    TypeError: webhookManager.processSentence is not a function

      285 |
      286 |       // Process a short sentence with empty current chunk
    > 287 |       let result = webhookManager.processSentence('This is a short sentence.', chunks, '');
          |                                   ^
      288 |       expect(result).toBe('This is a short sentence.');
      289 |       expect(chunks.length).toBe(0);
      290 |

      at Object.processSentence (tests/unit/webhookManager.helpers.test.js:287:35)

  ● WebhookManager - Helper Functions › Message splitting › processLine should handle lines correctly

    TypeError: webhookManager.processLine is not a function

      309 |
      310 |       // Process a short line
    > 311 |       let result = webhookManager.processLine('This is a short line', chunks, '');
          |                                   ^
      312 |       expect(result).toBe('This is a short line');
      313 |
      314 |       // Process a line with newlines

      at Object.processLine (tests/unit/webhookManager.helpers.test.js:311:35)

  ● WebhookManager - Helper Functions › Message splitting › processParagraph should handle paragraphs correctly

    TypeError: webhookManager.processParagraph is not a function

      331 |
      332 |       // Process a short paragraph
    > 333 |       let result = webhookManager.processParagraph('This is a short paragraph.', chunks, '');
          |                                   ^
      334 |       expect(result).toBe('This is a short paragraph.');
      335 |
      336 |       // Process another paragraph

      at Object.processParagraph (tests/unit/webhookManager.helpers.test.js:333:35)

 FAIL  tests/unit/application/bootstrap/ApplicationBootstrap.test.js
  ● ApplicationBootstrap › Initialization › should initialize successfully with all components

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Initialization › should initialize successfully with all components

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Initialization › should create event bus and wire up event handlers when events enabled

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Initialization › should create event bus and wire up event handlers when events enabled

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Initialization › should skip event handlers when events disabled

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Initialization › should skip event handlers when events disabled

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Initialization › should configure PersonalityRouter with application service

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Initialization › should configure PersonalityRouter with application service

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Initialization › should initialize command components

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Initialization › should initialize command components

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Initialization › should not reinitialize if already initialized

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Initialization › should not reinitialize if already initialized

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Initialization › should handle initialization errors gracefully

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Initialization › should handle initialization errors gracefully

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Service Access › should provide access to application services after initialization

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Service Access › should provide access to application services after initialization

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Service Access › should provide access to event bus after initialization

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Service Access › should provide access to event bus after initialization

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Service Access › should throw error when accessing services before initialization

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Service Access › should throw error when accessing services before initialization

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Shutdown › should shutdown cleanly

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Shutdown › should shutdown cleanly

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Shutdown › should handle shutdown when not initialized

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Shutdown › should handle shutdown when not initialized

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Shutdown › should handle shutdown when event handlers not registered

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Shutdown › should handle shutdown when event handlers not registered

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Singleton Pattern › should return same instance for getApplicationBootstrap

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Singleton Pattern › should return same instance for getApplicationBootstrap

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Singleton Pattern › should reset singleton and allow new instance

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Singleton Pattern › should reset singleton and allow new instance

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Singleton Pattern › should handle reset with shutdown errors gracefully

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Singleton Pattern › should handle reset with shutdown errors gracefully

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Feature Logging › should log active features during initialization

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Feature Logging › should log active features during initialization

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Environment Configuration › should use environment variables for AI service configuration

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Environment Configuration › should use environment variables for AI service configuration

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

  ● ApplicationBootstrap › Environment Configuration › should use default values when environment variables not set

    TypeError: resetApplicationBootstrap is not a function

      103 |
      104 |     // Reset singleton
    > 105 |     resetApplicationBootstrap();
          |     ^
      106 |   });
      107 |
      108 |   afterEach(() => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:105:5)

  ● ApplicationBootstrap › Environment Configuration › should use default values when environment variables not set

    TypeError: resetApplicationBootstrap is not a function

      107 |
      108 |   afterEach(() => {
    > 109 |     resetApplicationBootstrap();
          |     ^
      110 |   });
      111 |
      112 |   describe('Initialization', () => {

      at Object.resetApplicationBootstrap (tests/unit/application/bootstrap/ApplicationBootstrap.test.js:109:5)

 FAIL  tests/unit/webhookManager.test.js
  ● WebhookManager › isDuplicateMessage and hashMessage › should create a consistent hash for a message

    TypeError: webhookManager.hashMessage is not a function

      106 |       const channelId = 'channel-123';
      107 |
    > 108 |       const hash1 = webhookManager.hashMessage(content, username, channelId);
          |                                    ^
      109 |       const hash2 = webhookManager.hashMessage(content, username, channelId);
      110 |
      111 |       // Same inputs should produce the same hash

      at Object.hashMessage (tests/unit/webhookManager.test.js:108:36)

  ● WebhookManager › isDuplicateMessage and hashMessage › should detect a duplicate message

    TypeError: webhookManager.isDuplicateMessage is not a function

      123 |
      124 |       // First time is not a duplicate
    > 125 |       expect(webhookManager.isDuplicateMessage(content, username, channelId)).toBe(false);
          |                             ^
      126 |
      127 |       // Second time should be detected as duplicate
      128 |       expect(webhookManager.isDuplicateMessage(content, username, channelId)).toBe(true);

      at Object.isDuplicateMessage (tests/unit/webhookManager.test.js:125:29)

  ● WebhookManager › isDuplicateMessage and hashMessage › should not consider different messages as duplicates

    TypeError: webhookManager.isDuplicateMessage is not a function

      134 |
      135 |       // First message
    > 136 |       expect(webhookManager.isDuplicateMessage('First message', username, channelId)).toBe(false);
          |                             ^
      137 |
      138 |       // Different content should not be a duplicate
      139 |       expect(webhookManager.isDuplicateMessage('Second message', username, channelId)).toBe(false);

      at Object.isDuplicateMessage (tests/unit/webhookManager.test.js:136:29)

  ● WebhookManager › isDuplicateMessage and hashMessage › should not consider empty content as a duplicate

    TypeError: webhookManager.isDuplicateMessage is not a function

      150 |       const channelId = 'channel-123';
      151 |
    > 152 |       expect(webhookManager.isDuplicateMessage('', username, channelId)).toBe(false);
          |                             ^
      153 |       expect(webhookManager.isDuplicateMessage(null, username, channelId)).toBe(false);
      154 |       expect(webhookManager.isDuplicateMessage(undefined, username, channelId)).toBe(false);
      155 |     });

      at Object.isDuplicateMessage (tests/unit/webhookManager.test.js:152:29)

  ● WebhookManager › getStandardizedUsername › should prioritize displayName if available

    TypeError: webhookManager.getStandardizedUsername is not a function

      163 |       };
      164 |
    > 165 |       expect(webhookManager.getStandardizedUsername(personality)).toBe('Display Name');
          |                             ^
      166 |     });
      167 |
      168 |     it('should fall back to first part of fullName if no displayName', () => {

      at Object.getStandardizedUsername (tests/unit/webhookManager.test.js:165:29)

  ● WebhookManager › getStandardizedUsername › should fall back to first part of fullName if no displayName

    TypeError: webhookManager.getStandardizedUsername is not a function

      171 |       };
      172 |
    > 173 |       expect(webhookManager.getStandardizedUsername(personality)).toBe('First');
          |                             ^
      174 |     });
      175 |
      176 |     it('should use fullName if no hyphens and under limit', () => {

      at Object.getStandardizedUsername (tests/unit/webhookManager.test.js:173:29)

  ● WebhookManager › getStandardizedUsername › should use fullName if no hyphens and under limit

    TypeError: webhookManager.getStandardizedUsername is not a function

      180 |
      181 |       // Use a case-insensitive match because the implementation capitalizes the first letter
    > 182 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      183 |       expect(result.toLowerCase()).toBe('shortname'.toLowerCase());
      184 |     });
      185 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.test.js:182:37)

  ● WebhookManager › getStandardizedUsername › should truncate names longer than 32 characters

    TypeError: webhookManager.getStandardizedUsername is not a function

      189 |       };
      190 |
    > 191 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      192 |       expect(result.length).toBeLessThanOrEqual(32);
      193 |       expect(result).toContain('...');
      194 |     });

      at Object.getStandardizedUsername (tests/unit/webhookManager.test.js:191:37)

  ● WebhookManager › getStandardizedUsername › should return "Bot" for null or undefined personality

    TypeError: webhookManager.getStandardizedUsername is not a function

      195 |
      196 |     it('should return "Bot" for null or undefined personality', () => {
    > 197 |       expect(webhookManager.getStandardizedUsername(null)).toBe('Bot');
          |                             ^
      198 |       expect(webhookManager.getStandardizedUsername(undefined)).toBe('Bot');
      199 |       expect(webhookManager.getStandardizedUsername({})).toBe('Bot');
      200 |     });

      at Object.getStandardizedUsername (tests/unit/webhookManager.test.js:197:29)

  ● WebhookManager › Pending Message Tracking › should create a consistent key for personality-channel combinations

    TypeError: webhookManager.createPersonalityChannelKey is not a function

      211 |       const channelId = 'channel-123';
      212 |
    > 213 |       const key = webhookManager.createPersonalityChannelKey(personalityName, channelId);
          |                                  ^
      214 |       expect(key).toBe('test-personality_channel-123');
      215 |     });
      216 |

      at Object.createPersonalityChannelKey (tests/unit/webhookManager.test.js:213:34)

  ● WebhookManager › Pending Message Tracking › should register and detect pending messages

    TypeError: webhookManager.hasPersonalityPendingMessage is not a function

      221 |
      222 |       // Initially should have no pending message
    > 223 |       expect(webhookManager.hasPersonalityPendingMessage(personalityName, channelId)).toBe(false);
          |                             ^
      224 |
      225 |       // Register a pending message
      226 |       webhookManager.registerPendingMessage(personalityName, channelId, content, false);

      at Object.hasPersonalityPendingMessage (tests/unit/webhookManager.test.js:223:29)

  ● WebhookManager › Pending Message Tracking › should expire pending messages after timeout

    TypeError: webhookManager.registerPendingMessage is not a function

      242 |
      243 |       // Register a pending message
    > 244 |       webhookManager.registerPendingMessage(personalityName, channelId, content, false);
          |                      ^
      245 |
      246 |       // Should detect a pending message
      247 |       expect(webhookManager.hasPersonalityPendingMessage(personalityName, channelId)).toBe(true);

      at Object.registerPendingMessage (tests/unit/webhookManager.test.js:244:22)

 FAIL  tests/unit/webhookManager.exports.test.js
  ● WebhookManager - Exported Functions › getStandardizedUsername › should prioritize displayName if available

    TypeError: webhookManager.getStandardizedUsername is not a function

      93 |       };
      94 |
    > 95 |       const result = webhookManager.getStandardizedUsername(personality);
         |                                     ^
      96 |       expect(result).toBe('Test Display Name');
      97 |     });
      98 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.exports.test.js:95:37)

  ● WebhookManager - Exported Functions › getStandardizedUsername › should truncate display names longer than 32 characters

    TypeError: webhookManager.getStandardizedUsername is not a function

      102 |       };
      103 |
    > 104 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      105 |       expect(result.length).toBeLessThanOrEqual(32);
      106 |       expect(result).toContain('...');
      107 |     });

      at Object.getStandardizedUsername (tests/unit/webhookManager.exports.test.js:104:37)

  ● WebhookManager - Exported Functions › getStandardizedUsername › should extract name from fullName if displayName is not available

    TypeError: webhookManager.getStandardizedUsername is not a function

      112 |       };
      113 |
    > 114 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      115 |       // Should capitalize the first part of the hyphenated name
      116 |       expect(result).toBe('Test');
      117 |     });

      at Object.getStandardizedUsername (tests/unit/webhookManager.exports.test.js:114:37)

  ● WebhookManager - Exported Functions › getStandardizedUsername › should use fullName if it has no hyphens and is short enough

    TypeError: webhookManager.getStandardizedUsername is not a function

      122 |       };
      123 |
    > 124 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      125 |       // Should capitalize the first letter
      126 |       expect(result).toBe('Shortname');
      127 |     });

      at Object.getStandardizedUsername (tests/unit/webhookManager.exports.test.js:124:37)

  ● WebhookManager - Exported Functions › getStandardizedUsername › should return "Bot" for null or undefined personality

    TypeError: webhookManager.getStandardizedUsername is not a function

      128 |
      129 |     it('should return "Bot" for null or undefined personality', () => {
    > 130 |       expect(webhookManager.getStandardizedUsername(null)).toBe('Bot');
          |                             ^
      131 |       expect(webhookManager.getStandardizedUsername(undefined)).toBe('Bot');
      132 |     });
      133 |   });

      at Object.getStandardizedUsername (tests/unit/webhookManager.exports.test.js:130:29)

  ● WebhookManager - Exported Functions › hashMessage and isDuplicateMessage › should create a consistent hash for a message

    TypeError: webhookManager.hashMessage is not a function

      139 |       const channelId = 'channel-123';
      140 |
    > 141 |       const hash1 = webhookManager.hashMessage(content, username, channelId);
          |                                    ^
      142 |       const hash2 = webhookManager.hashMessage(content, username, channelId);
      143 |
      144 |       // Same inputs should produce the same hash

      at Object.hashMessage (tests/unit/webhookManager.exports.test.js:141:36)

  ● WebhookManager - Exported Functions › hashMessage and isDuplicateMessage › should detect duplicate messages

    TypeError: webhookManager.isDuplicateMessage is not a function

      156 |
      157 |       // First message should not be a duplicate
    > 158 |       expect(webhookManager.isDuplicateMessage(content, username, channelId)).toBe(false);
          |                             ^
      159 |
      160 |       // Second identical message should be detected as a duplicate
      161 |       expect(webhookManager.isDuplicateMessage(content, username, channelId)).toBe(true);

      at Object.isDuplicateMessage (tests/unit/webhookManager.exports.test.js:158:29)

  ● WebhookManager - Exported Functions › hashMessage and isDuplicateMessage › should not detect different messages as duplicates

    TypeError: webhookManager.isDuplicateMessage is not a function

      167 |
      168 |       // First message
    > 169 |       expect(webhookManager.isDuplicateMessage('First message', username, channelId)).toBe(false);
          |                             ^
      170 |
      171 |       // Different content
      172 |       expect(webhookManager.isDuplicateMessage('Second message', username, channelId)).toBe(false);

      at Object.isDuplicateMessage (tests/unit/webhookManager.exports.test.js:169:29)

  ● WebhookManager - Exported Functions › hashMessage and isDuplicateMessage › should not flag empty content as duplicate

    TypeError: webhookManager.isDuplicateMessage is not a function

      183 |       const channelId = 'channel-123';
      184 |
    > 185 |       expect(webhookManager.isDuplicateMessage('', username, channelId)).toBe(false);
          |                             ^
      186 |       expect(webhookManager.isDuplicateMessage(null, username, channelId)).toBe(false);
      187 |       expect(webhookManager.isDuplicateMessage(undefined, username, channelId)).toBe(false);
      188 |     });

      at Object.isDuplicateMessage (tests/unit/webhookManager.exports.test.js:185:29)

  ● WebhookManager - Exported Functions › Pending message functions › should create a consistent key format for personality-channel combinations

    TypeError: webhookManager.createPersonalityChannelKey is not a function

      199 |       const channelId = 'channel-123';
      200 |
    > 201 |       const key = webhookManager.createPersonalityChannelKey(personalityName, channelId);
          |                                  ^
      202 |       expect(key).toBe('test-personality_channel-123');
      203 |     });
      204 |

      at Object.createPersonalityChannelKey (tests/unit/webhookManager.exports.test.js:201:34)

  ● WebhookManager - Exported Functions › Pending message functions › should register and detect pending messages

    TypeError: webhookManager.hasPersonalityPendingMessage is not a function

      209 |
      210 |       // Initially no pending message
    > 211 |       expect(webhookManager.hasPersonalityPendingMessage(personalityName, channelId)).toBe(false);
          |                             ^
      212 |
      213 |       // Register a pending message
      214 |       webhookManager.registerPendingMessage(personalityName, channelId, content, false);

      at Object.hasPersonalityPendingMessage (tests/unit/webhookManager.exports.test.js:211:29)

  ● WebhookManager - Exported Functions › Pending message functions › should timeout pending messages after the error wait time

    TypeError: webhookManager.registerPendingMessage is not a function

      238 |
      239 |         // Register a pending message
    > 240 |         webhookManager.registerPendingMessage(personalityName, channelId, content, false);
          |                        ^
      241 |
      242 |         // Should have a pending message
      243 |         expect(webhookManager.hasPersonalityPendingMessage(personalityName, channelId)).toBe(true);

      at Object.registerPendingMessage (tests/unit/webhookManager.exports.test.js:240:24)

  ● WebhookManager - Exported Functions › Message timing functions › should calculate delay needed for proper message ordering

    TypeError: webhookManager.calculateMessageDelay is not a function

      269 |
      270 |         // Initially should not need a delay
    > 271 |         expect(webhookManager.calculateMessageDelay(channelId)).toBe(0);
          |                               ^
      272 |
      273 |         // Update last message time for the channel
      274 |         webhookManager.updateChannelLastMessageTime(channelId);

      at Object.calculateMessageDelay (tests/unit/webhookManager.exports.test.js:271:31)

  ● WebhookManager - Exported Functions › Webhook cache functions › should have clearWebhookCache and clearAllWebhookCaches functions exported

    expect(received).toBe(expected) // Object.is equality

    Expected: "function"
    Received: "undefined"

      298 |
      299 |     it('should have clearWebhookCache and clearAllWebhookCaches functions exported', () => {
    > 300 |       expect(typeof webhookManager.clearWebhookCache).toBe('function');
          |                                                       ^
      301 |       expect(typeof webhookManager.clearAllWebhookCaches).toBe('function');
      302 |     });
      303 |

      at Object.toBe (tests/unit/webhookManager.exports.test.js:300:55)

  ● WebhookManager - Exported Functions › preloadPersonalityAvatar › should be an exported function that handles avatars

    expect(received).toBe(expected) // Object.is equality

    Expected: "function"
    Received: "undefined"

      309 |     it('should be an exported function that handles avatars', () => {
      310 |       // Verify the function exists
    > 311 |       expect(typeof webhookManager.preloadPersonalityAvatar).toBe('function');
          |                                                              ^
      312 |
      313 |       // Create a personality with no avatar to avoid actual fetch calls
      314 |       const personality = {

      at Object.toBe (tests/unit/webhookManager.exports.test.js:311:62)

 FAIL  tests/unit/webhookManager.avatar.test.js
  ● WebhookManager Avatar URL Handling › Basic Avatar URL Validation › should return false for null or empty URLs

    TypeError: webhookManager.validateAvatarUrl is not a function

      86 |   describe('Basic Avatar URL Validation', () => {
      87 |     test('should return false for null or empty URLs', async () => {
    > 88 |       expect(await webhookManager.validateAvatarUrl(null)).toBe(false);
         |                                   ^
      89 |       expect(await webhookManager.validateAvatarUrl('')).toBe(false);
      90 |       expect(await webhookManager.validateAvatarUrl(undefined)).toBe(false);
      91 |     });

      at validateAvatarUrl (tests/unit/webhookManager.avatar.test.js:88:35)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › Basic Avatar URL Validation › should return false for invalid URL formats

    TypeError: webhookManager.validateAvatarUrl is not a function

      92 |
      93 |     test('should return false for invalid URL formats', async () => {
    > 94 |       expect(await webhookManager.validateAvatarUrl('not-a-url')).toBe(false);
         |                                   ^
      95 |     });
      96 |
      97 |     test('should handle non-200 responses', async () => {

      at validateAvatarUrl (tests/unit/webhookManager.avatar.test.js:94:35)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › Basic Avatar URL Validation › should handle non-200 responses

    TypeError: webhookManager.validateAvatarUrl is not a function

      112 |         // In the updated code, we treat image extensions specially in the test for CDN compatibility
      113 |         // When running in tests, all we care about is that the function completes without errors
    > 114 |         await webhookManager.validateAvatarUrl('https://example.com/notfound.png');
          |                              ^
      115 |       } finally {
      116 |         // Restore original NODE_ENV
      117 |         process.env.NODE_ENV = origNodeEnv;

      at validateAvatarUrl (tests/unit/webhookManager.avatar.test.js:114:30)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › Basic Avatar URL Validation › should return false for non-image content types

    TypeError: webhookManager.validateAvatarUrl is not a function

      129 |       }));
      130 |
    > 131 |       expect(await webhookManager.validateAvatarUrl('https://example.com/page.html')).toBe(false);
          |                                   ^
      132 |     });
      133 |
      134 |     test('should handle network errors gracefully', async () => {

      at validateAvatarUrl (tests/unit/webhookManager.avatar.test.js:131:35)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › Basic Avatar URL Validation › should handle network errors gracefully

    TypeError: webhookManager.validateAvatarUrl is not a function

      141 |       try {
      142 |         // Just check that it completes without throwing
    > 143 |         await webhookManager.validateAvatarUrl('https://example.com/error.png');
          |                              ^
      144 |       } finally {
      145 |         // Restore original NODE_ENV
      146 |         process.env.NODE_ENV = origNodeEnv;

      at validateAvatarUrl (tests/unit/webhookManager.avatar.test.js:143:30)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › getValidAvatarUrl function › should return null for null or empty URLs

    TypeError: webhookManager.getValidAvatarUrl is not a function

      151 |   describe('getValidAvatarUrl function', () => {
      152 |     test('should return null for null or empty URLs', async () => {
    > 153 |       expect(await webhookManager.getValidAvatarUrl(null)).toBe(null);
          |                                   ^
      154 |       expect(await webhookManager.getValidAvatarUrl('')).toBe(null);
      155 |       expect(await webhookManager.getValidAvatarUrl(undefined)).toBe(null);
      156 |     });

      at getValidAvatarUrl (tests/unit/webhookManager.avatar.test.js:153:35)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › getValidAvatarUrl function › should return original URL when validation passes

    TypeError: webhookManager.getValidAvatarUrl is not a function

      162 |
      163 |       try {
    > 164 |         const result = await webhookManager.getValidAvatarUrl(validUrl);
          |                                             ^
      165 |         expect(result).toBe(validUrl);
      166 |       } finally {
      167 |         // Restore original function

      at getValidAvatarUrl (tests/unit/webhookManager.avatar.test.js:164:45)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › getValidAvatarUrl function › should handle validation failures

    TypeError: webhookManager.getValidAvatarUrl is not a function

      177 |       try {
      178 |         // Just verify it completes - the exact return value may change based on our implementation
    > 179 |         await webhookManager.getValidAvatarUrl(validUrl);
          |                              ^
      180 |       } finally {
      181 |         // Restore original function
      182 |         webhookManager.validateAvatarUrl = original;

      at getValidAvatarUrl (tests/unit/webhookManager.avatar.test.js:179:30)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › warmupAvatarUrl function › should return null for null URLs

    TypeError: webhookManager.warmupAvatarUrl is not a function

      187 |   describe('warmupAvatarUrl function', () => {
      188 |     test('should return null for null URLs', async () => {
    > 189 |       expect(await webhookManager.warmupAvatarUrl(null)).toBe(null);
          |                                   ^
      190 |     });
      191 |
      192 |     test('should return URL from cache if already warmed up', async () => {

      at warmupAvatarUrl (tests/unit/webhookManager.avatar.test.js:189:35)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › warmupAvatarUrl function › should return URL from cache if already warmed up

    TypeError: webhookManager.warmupAvatarUrl is not a function

      195 |
      196 |       // Should return from cache without calling fetch
    > 197 |       const result = await webhookManager.warmupAvatarUrl(validUrl);
          |                                           ^
      198 |
      199 |       expect(result).toBe(validUrl);
      200 |       expect(nodeFetch).not.toHaveBeenCalled();

      at warmupAvatarUrl (tests/unit/webhookManager.avatar.test.js:197:43)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › warmupAvatarUrl function › should handle valid URLs

    TypeError: webhookManager.warmupAvatarUrl is not a function

      208 |       try {
      209 |         // Just verify it completes - the exact behavior may change
    > 210 |         await webhookManager.warmupAvatarUrl(validUrl);
          |                              ^
      211 |       } finally {
      212 |         // Restore original function
      213 |         webhookManager.getValidAvatarUrl = originalGetValidAvatarUrl;

      at warmupAvatarUrl (tests/unit/webhookManager.avatar.test.js:210:30)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › warmupAvatarUrl function › should handle warmup failures gracefully

    TypeError: webhookManager.warmupAvatarUrl is not a function

      225 |       try {
      226 |         // Just verify it completes without throwing
    > 227 |         await webhookManager.warmupAvatarUrl(validUrl);
          |                              ^
      228 |       } finally {
      229 |         // Restore original function
      230 |         webhookManager.getValidAvatarUrl = originalGetValidAvatarUrl;

      at warmupAvatarUrl (tests/unit/webhookManager.avatar.test.js:227:30)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › warmupAvatarUrl function › should handle non-stream response bodies correctly

    TypeError: webhookManager.warmupAvatarUrl is not a function

      254 |       try {
      255 |         // Should complete successfully using arrayBuffer fallback
    > 256 |         const result = await webhookManager.warmupAvatarUrl(validUrl);
          |                                             ^
      257 |         expect(result).toBe(validUrl);
      258 |       } finally {
      259 |         // Restore original function

      at warmupAvatarUrl (tests/unit/webhookManager.avatar.test.js:256:45)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › warmupAvatarUrl function › should handle response with only text method available

    TypeError: webhookManager.warmupAvatarUrl is not a function

      284 |       try {
      285 |         // Should complete successfully using text fallback
    > 286 |         const result = await webhookManager.warmupAvatarUrl(validUrl);
          |                                             ^
      287 |         expect(result).toBe(validUrl);
      288 |       } finally {
      289 |         // Restore original function

      at warmupAvatarUrl (tests/unit/webhookManager.avatar.test.js:286:45)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › warmupAvatarUrl function › should handle response with no read methods available

    TypeError: webhookManager.warmupAvatarUrl is not a function

      313 |       try {
      314 |         // Should still complete successfully using status code
    > 315 |         const result = await webhookManager.warmupAvatarUrl(validUrl);
          |                                             ^
      316 |         expect(result).toBe(validUrl);
      317 |       } finally {
      318 |         // Restore original function

      at warmupAvatarUrl (tests/unit/webhookManager.avatar.test.js:315:45)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › preloadPersonalityAvatar function › should set null for personalities without avatar URL

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      331 |
      332 |       // Call the function
    > 333 |       await webhookManager.preloadPersonalityAvatar(personality);
          |                            ^
      334 |
      335 |       // Should set null
      336 |       expect(personality.avatarUrl).toBe(null);

      at preloadPersonalityAvatar (tests/unit/webhookManager.avatar.test.js:333:28)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › preloadPersonalityAvatar function › should validate and update invalid avatar URLs

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      349 |
      350 |       // Call the function
    > 351 |       await webhookManager.preloadPersonalityAvatar(personality);
          |                            ^
      352 |
      353 |       // Should update to null when warmup fails
      354 |       expect(personality.avatarUrl).toBe(null);

      at preloadPersonalityAvatar (tests/unit/webhookManager.avatar.test.js:351:28)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

  ● WebhookManager Avatar URL Handling › preloadPersonalityAvatar function › should handle null personality gracefully

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      356 |
      357 |     test('should handle null personality gracefully', async () => {
    > 358 |       await expect(webhookManager.preloadPersonalityAvatar(null)).resolves.not.toThrow();
          |                                   ^
      359 |     });
      360 |   });
      361 | });

      at preloadPersonalityAvatar (tests/unit/webhookManager.avatar.test.js:358:35)
      at Generator.call (tests/unit/webhookManager.avatar.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.avatar.test.js:2:1)
      at _next (tests/unit/webhookManager.avatar.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.avatar.test.js:2:1)

 FAIL  tests/unit/handlers/dmHandler.test.js
  ● dmHandler › handleDmReply › should handle errors when personality interaction fails

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should return false when no personality is found after all lookup attempts

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should handle replies to personality messages in DMs

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should handle replies to continued messages without personality prefix

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should handle personality names with server suffixes

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should match personality by exact display name

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should match personality by display name prefix

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should match personality by first part of full name

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should try multiple personality lookup methods

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should not handle replies to non-bot messages

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should not handle non-DM messages

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should not handle messages from bots

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should not handle messages without references

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should find personality from earlier message in multi-chunk scenario

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should match personality by standardized username

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should match personality by exact full name

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should handle errors when looking up previous messages for multi-chunk

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDmReply › should skip personalities with null or undefined fullName

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should handle errors when sending verification prompt

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should handle errors when sending personality summon prompt

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should use personality from alias when direct lookup fails

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should handle direct messages with active personalities

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should prompt user to verify if not verified

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should bypass verification for trusted proxy systems

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should find personality by global alias when user-specific alias fails

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should prompt user to summon a personality if no active personality

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should not handle non-DM messages

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should not handle messages from bots

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

  ● dmHandler › handleDirectMessage › should return false when personality exists but both lookups return null

    TypeError: Cannot read properties of undefined (reading 'mockImplementation')

      83 |     getPersonalityByAlias.mockReturnValue(null);
      84 |     listPersonalitiesForUser.mockReturnValue([mockPersonality]);
    > 85 |     getStandardizedUsername.mockImplementation(personality => personality.displayName);
         |                             ^
      86 |   });
      87 |
      88 |   describe('handleDmReply', () => {

      at Object.mockImplementation (tests/unit/handlers/dmHandler.test.js:85:29)

 FAIL  tests/unit/webhookManager.creation.test.js
  ● WebhookManager - Webhook Creation and Management › preloadPersonalityAvatar › should preload a personality avatar

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      186 |
      187 |       // Call the function
    > 188 |       await webhookManager.preloadPersonalityAvatar(personality);
          |                            ^
      189 |
      190 |       // Verify fetch was called with the avatar URL
      191 |       const fetch = require('node-fetch');

      at preloadPersonalityAvatar (tests/unit/webhookManager.creation.test.js:188:28)
      at Generator.call (tests/unit/webhookManager.creation.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.creation.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.creation.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.creation.test.js:2:1)
      at _next (tests/unit/webhookManager.creation.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.creation.test.js:2:1)

  ● WebhookManager - Webhook Creation and Management › preloadPersonalityAvatar › should handle personalities with no avatar URL

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      210 |
      211 |       // Call the function
    > 212 |       await webhookManager.preloadPersonalityAvatar(personality);
          |                            ^
      213 |
      214 |       // Verify fetch was not called
      215 |       const fetch = require('node-fetch');

      at preloadPersonalityAvatar (tests/unit/webhookManager.creation.test.js:212:28)
      at Generator.call (tests/unit/webhookManager.creation.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.creation.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.creation.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.creation.test.js:2:1)
      at _next (tests/unit/webhookManager.creation.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.creation.test.js:2:1)

  ● WebhookManager - Webhook Creation and Management › preloadPersonalityAvatar › should handle null or undefined personalities

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      223 |     it('should handle null or undefined personalities', async () => {
      224 |       // Call the function with null personality
    > 225 |       await webhookManager.preloadPersonalityAvatar(null);
          |                            ^
      226 |
      227 |       // Verify fetch was not called
      228 |       const fetch = require('node-fetch');

      at preloadPersonalityAvatar (tests/unit/webhookManager.creation.test.js:225:28)
      at Generator.call (tests/unit/webhookManager.creation.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.creation.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.creation.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.creation.test.js:2:1)
      at _next (tests/unit/webhookManager.creation.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.creation.test.js:2:1)

  ● WebhookManager - Webhook Creation and Management › getStandardizedUsername › should prioritize displayName if available

    TypeError: webhookManager.getStandardizedUsername is not a function

      242 |       };
      243 |
    > 244 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      245 |       expect(result).toBe('Test Display Name');
      246 |     });
      247 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.creation.test.js:244:37)

  ● WebhookManager - Webhook Creation and Management › getStandardizedUsername › should truncate display names longer than 32 characters

    TypeError: webhookManager.getStandardizedUsername is not a function

      251 |       };
      252 |
    > 253 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      254 |       expect(result.length).toBeLessThanOrEqual(32);
      255 |       expect(result).toContain('...');
      256 |     });

      at Object.getStandardizedUsername (tests/unit/webhookManager.creation.test.js:253:37)

  ● WebhookManager - Webhook Creation and Management › getStandardizedUsername › should extract name from fullName if displayName is not available

    TypeError: webhookManager.getStandardizedUsername is not a function

      261 |       };
      262 |
    > 263 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      264 |       // Should extract the first part before the hyphen
      265 |       expect(result).toBe('Test');
      266 |     });

      at Object.getStandardizedUsername (tests/unit/webhookManager.creation.test.js:263:37)

  ● WebhookManager - Webhook Creation and Management › getStandardizedUsername › should use fullName if it has no hyphens and is short enough

    TypeError: webhookManager.getStandardizedUsername is not a function

      271 |       };
      272 |
    > 273 |       const result = webhookManager.getStandardizedUsername(personality);
          |                                     ^
      274 |       expect(result).toBe('Shortname');
      275 |     });
      276 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.creation.test.js:273:37)

  ● WebhookManager - Webhook Creation and Management › getStandardizedUsername › should return "Bot" for null or undefined personality

    TypeError: webhookManager.getStandardizedUsername is not a function

      276 |
      277 |     it('should return "Bot" for null or undefined personality', () => {
    > 278 |       expect(webhookManager.getStandardizedUsername(null)).toBe('Bot');
          |                             ^
      279 |       expect(webhookManager.getStandardizedUsername(undefined)).toBe('Bot');
      280 |     });
      281 |   });

      at Object.getStandardizedUsername (tests/unit/webhookManager.creation.test.js:278:29)

 FAIL  tests/unit/handlers/messageHandler.mentions.test.js
  ● checkForPersonalityMentions › single word mentions › should return false for invalid mention

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      66 |       const result = await checkForPersonalityMentions(message);
      67 |
    > 68 |       expect(result).toBe(false);
         |                      ^
      69 |     });
      70 |   });
      71 |

      at toBe (tests/unit/handlers/messageHandler.mentions.test.js:68:22)
      at Generator.call (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)

  ● checkForPersonalityMentions › multi-word mentions › should detect valid two-word personality mention

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "angel dust"
    Received: "angel"

    Number of calls: 1

      84 |
      85 |       expect(result).toBe(true);
    > 86 |       expect(getPersonalityByAlias).toHaveBeenCalledWith('angel dust');
         |                                     ^
      87 |     });
      88 |
      89 |     it('should handle multi-word mention at end of message', async () => {

      at toHaveBeenCalledWith (tests/unit/handlers/messageHandler.mentions.test.js:86:37)
      at Generator.call (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)

  ● checkForPersonalityMentions › multi-word mentions › should handle multi-word mention with punctuation

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "angel dust"
    Received: "angel"

    Number of calls: 1

      107 |
      108 |       expect(result).toBe(true);
    > 109 |       expect(getPersonalityByAlias).toHaveBeenCalledWith('angel dust');
          |                                     ^
      110 |     });
      111 |
      112 |     it('should handle three-word aliases when max is 3', async () => {

      at toHaveBeenCalledWith (tests/unit/handlers/messageHandler.mentions.test.js:109:37)
      at Generator.call (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)

  ● checkForPersonalityMentions › multi-word mentions › should handle three-word aliases when max is 3

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "the dark lord"
    Received: "the"

    Number of calls: 1

      121 |
      122 |       expect(result).toBe(true);
    > 123 |       expect(getPersonalityByAlias).toHaveBeenCalledWith('the dark lord');
          |                                     ^
      124 |     });
      125 |
      126 |     it('should not check beyond max word count', async () => {

      at toHaveBeenCalledWith (tests/unit/handlers/messageHandler.mentions.test.js:123:37)
      at Generator.call (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)

  ● checkForPersonalityMentions › edge cases › should handle mentions with multiple spaces

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "angel dust"
    Received: "angel"

    Number of calls: 1

      178 |       expect(result).toBe(true);
      179 |       // Should normalize spaces
    > 180 |       expect(getPersonalityByAlias).toHaveBeenCalledWith('angel dust');
          |                                     ^
      181 |     });
      182 |
      183 |     // Note: Testing different mention characters (@ vs &) requires complex module mocking

      at toHaveBeenCalledWith (tests/unit/handlers/messageHandler.mentions.test.js:180:37)
      at Generator.call (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)

  ● checkForPersonalityMentions › regex generation based on max word count › should generate correct regex for 5 word max

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "one two three four five"
    Received: "one"

    Number of calls: 1

      209 |
      210 |       // Should check up to 5 words
    > 211 |       expect(getPersonalityByAlias).toHaveBeenCalledWith('one two three four five');
          |                                     ^
      212 |       // Should not check 6 words
      213 |       expect(getPersonalityByAlias).not.toHaveBeenCalledWith('one two three four five six');
      214 |     });

      at toHaveBeenCalledWith (tests/unit/handlers/messageHandler.mentions.test.js:211:37)
      at Generator.call (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)
      at asyncGeneratorStep (tests/unit/handlers/messageHandler.mentions.test.js:2:1)

 FAIL  tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js
  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should check for blackout before processing

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      80 |       mockDeduplicator.isInBlackout.mockReturnValue(true);
      81 |
    > 82 |       await expect(adapter.sendRequest(request))
         |             ^
      83 |         .rejects.toThrow('Request blocked due to recent errors');
      84 |
      85 |       expect(mockDeduplicator.isInBlackout).toHaveBeenCalledWith('TestBot', '123456789012345678');

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:82:13)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should return cached promise for duplicate request

    TypeError: result.getText is not a function

      93 |       const result = await adapter.sendRequest(request);
      94 |
    > 95 |       expect(result.getText()).toBe('Cached response');
         |                     ^
      96 |       expect(mockDeduplicator.getPendingRequest).toHaveBeenCalled();
      97 |       expect(fetch).not.toHaveBeenCalled();
      98 |       expect(logger.info).toHaveBeenCalledWith(

      at getText (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:95:21)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should track new requests to prevent duplicates

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: Anything, Any<Promise>

    Number of calls: 0

      104 |       await adapter.sendRequest(request);
      105 |
    > 106 |       expect(mockDeduplicator.trackPendingRequest).toHaveBeenCalledWith(
          |                                                    ^
      107 |         expect.anything(),
      108 |         expect.any(Promise)
      109 |       );

      at toHaveBeenCalledWith (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:106:52)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should add to blackout on rate limit error

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      119 |       });
      120 |
    > 121 |       await expect(adapter.sendRequest(request)).rejects.toThrow();
          |             ^
      122 |
      123 |       // The promise catch handler should have been called synchronously
      124 |       // since we're using mockDeduplicator.trackPendingRequest

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:121:13)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should add to blackout on service error

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      148 |       });
      149 |
    > 150 |       await expect(adapter.sendRequest(request)).rejects.toThrow();
          |             ^
      151 |
      152 |       expect(mockDeduplicator.trackPendingRequest).toHaveBeenCalled();
      153 |       const trackedPromise = mockDeduplicator.trackPendingRequest.mock.calls[0][1];

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:150:13)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should not add to blackout on client errors

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      171 |       });
      172 |
    > 173 |       await expect(adapter.sendRequest(request)).rejects.toThrow();
          |             ^
      174 |
      175 |       expect(mockDeduplicator.trackPendingRequest).toHaveBeenCalled();
      176 |       const trackedPromise = mockDeduplicator.trackPendingRequest.mock.calls[0][1];

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:173:13)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should handle missing personality gracefully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"channelId": "987654321098765432", "content": "Hello AI", "personalityName": "default", "userId": "123456789012345678"}

    Number of calls: 0

      190 |       await adapter.sendRequest(request);
      191 |
    > 192 |       expect(mockDeduplicator.createSignature).toHaveBeenCalledWith({
          |                                                ^
      193 |         personalityName: 'default',
      194 |         userId: '123456789012345678',
      195 |         channelId: '987654321098765432',

      at toHaveBeenCalledWith (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:192:48)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › deduplication behavior › should handle missing user ID gracefully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"channelId": "987654321098765432", "content": "Hello AI", "personalityName": "TestBot", "userId": "system"}

    Number of calls: 0

      203 |       await adapter.sendRequest(request);
      204 |
    > 205 |       expect(mockDeduplicator.createSignature).toHaveBeenCalledWith({
          |                                                ^
      206 |         personalityName: 'TestBot',
      207 |         userId: 'system',
      208 |         channelId: '987654321098765432',

      at toHaveBeenCalledWith (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:205:48)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

  ● HttpAIServiceAdapter - Deduplication › statistics › should include deduplication stats

    TypeError: adapter.getStats is not a function

      220 |       });
      221 |
    > 222 |       const stats = adapter.getStats();
          |                             ^
      223 |
      224 |       expect(stats.deduplication).toEqual({
      225 |         pendingRequests: 5,

      at Object.getStats (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:222:29)

  ● HttpAIServiceAdapter - Deduplication › cleanup › should stop deduplicator on cleanup

    TypeError: adapter.cleanup is not a function

      232 |   describe('cleanup', () => {
      233 |     it('should stop deduplicator on cleanup', async () => {
    > 234 |       await adapter.cleanup();
          |                     ^
      235 |
      236 |       expect(mockDeduplicator.stop).toHaveBeenCalled();
      237 |       expect(logger.info).toHaveBeenCalledWith('[HttpAIServiceAdapter] Cleaning up resources');

      at cleanup (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:234:21)
      at Generator.call (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at _next (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/ai/HttpAIServiceAdapter.dedup.test.js:2:1)

 FAIL  tests/unit/adapters/persistence/FilePersonalityRepository.test.js
  ● FilePersonalityRepository › initialize › should create data directory if it does not exist

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "./test-data", {"recursive": true}

    Number of calls: 0

       98 |       await repository.initialize();
       99 |
    > 100 |       expect(fs.mkdir).toHaveBeenCalledWith('./test-data', { recursive: true });
          |                        ^
      101 |     });
      102 |
      103 |     it('should load existing data file', async () => {

      at toHaveBeenCalledWith (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:100:24)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › initialize › should load existing data file

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "test-data/test-personalities.json", "utf8"

    Number of calls: 0

      104 |       await repository.initialize();
      105 |
    > 106 |       expect(fs.readFile).toHaveBeenCalledWith(
          |                           ^
      107 |         path.join('./test-data', 'test-personalities.json'),
      108 |         'utf8'
      109 |       );

      at toHaveBeenCalledWith (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:106:27)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › initialize › should create new file if it does not exist

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "test-data/test-personalities.json.tmp", "{
      \"personalities\": {},
      \"aliases\": {}
    }", "utf8"

    Number of calls: 0

      119 |       await repository.initialize();
      120 |
    > 121 |       expect(fs.writeFile).toHaveBeenCalledWith(
          |                            ^
      122 |         path.join('./test-data', 'test-personalities.json.tmp'),
      123 |         JSON.stringify({ personalities: {}, aliases: {} }, null, 2),
      124 |         'utf8'

      at toHaveBeenCalledWith (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:121:28)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › initialize › should throw error for other file read errors

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: undefined

      133 |       fs.readFile.mockRejectedValue(new Error('Permission denied'));
      134 |
    > 135 |       await expect(repository.initialize()).rejects.toThrow(
          |             ^
      136 |         'Failed to initialize repository: Permission denied'
      137 |       );
      138 |     });

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:135:13)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at _next (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Object.<anonymous> (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › save › should save a personality

    expect(received).not.toBeNull()

    Received: null

      174 |       // Verify behavior - personality can be retrieved
      175 |       const saved = await repository.findById(new PersonalityId('new-personality'));
    > 176 |       expect(saved).not.toBeNull();
          |                         ^
      177 |       expect(saved.profile.displayName).toBe('New Personality');
      178 |       const byAlias = await repository.findByAlias('newbie');
      179 |       expect(byAlias).not.toBeNull();

      at toBeNull (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:176:25)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › save › should update existing personality

    TypeError: Cannot read properties of null (reading 'updateProfile')

      194 |       // Fetch and update real domain object
      195 |       const existingPersonality = await repository.findById(new PersonalityId('test-personality'));
    > 196 |       existingPersonality.updateProfile({
          |                           ^
      197 |         prompt: 'Updated prompt for test personality'
      198 |       });
      199 |

      at updateProfile (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:196:27)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › save › should handle save errors

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: true

      223 |       );
      224 |
    > 225 |       await expect(repository.save(personality)).rejects.toThrow(
          |             ^
      226 |         'Failed to save personality: Failed to persist data: Disk full'
      227 |       );
      228 |     });

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:225:13)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › save › should initialize if not already initialized

    expect(jest.fn()).toHaveBeenCalled()

    Expected number of calls: >= 1
    Received number of calls:    0

      245 |       await repository.save(personality);
      246 |
    > 247 |       expect(fs.mkdir).toHaveBeenCalled();
          |                        ^
      248 |       // Verify behavior - personality was saved
      249 |       const saved = await repository.findById(new PersonalityId('new-personality'));
      250 |       expect(saved).not.toBeNull();

      at toHaveBeenCalled (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:247:24)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findById › should find personality by ID

    expect(received).toBeInstanceOf(expected)

    Expected constructor: Personality

    Received value has no prototype
    Received value: null

      259 |
      260 |       // Verify returns real domain object
    > 261 |       expect(result).toBeInstanceOf(Personality);
          |                      ^
      262 |       expect(result.personalityId.value).toBe('test-personality');
      263 |       expect(result.ownerId.value).toBe('123456789012345678');
      264 |       expect(result.profile.displayName).toBe('Test Personality');

      at toBeInstanceOf (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:261:22)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findById › should handle errors during hydration

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: null

      290 |       await repository.initialize();
      291 |
    > 292 |       await expect(repository.findById(new PersonalityId('bad-data'))).rejects.toThrow(
          |             ^
      293 |         'Failed to find personality'
      294 |       );
      295 |     });

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:292:13)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findByOwner › should find all personalities by owner

    expect(received).toHaveLength(expected)

    Expected length: 2
    Received length: 0
    Received array:  []

      314 |
      315 |       // Verify returns real domain objects
    > 316 |       expect(results).toHaveLength(2);
          |                       ^
      317 |       expect(results[0]).toBeInstanceOf(Personality);
      318 |       expect(results[1]).toBeInstanceOf(Personality);
      319 |       expect(results.map(p => p.personalityId.value)).toEqual(['test-personality', 'test-personality-2']);

      at toHaveLength (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:316:23)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findByOwner › should handle errors during hydration

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: []

      344 |       await repository.initialize();
      345 |
    > 346 |       await expect(repository.findByOwner(new UserId('123456789012345678'))).rejects.toThrow(
          |             ^
      347 |         'Failed to find personalities by owner'
      348 |       );
      349 |     });

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:346:13)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findByAlias › should find personality by alias

    TypeError: repository.findByAlias is not a function

      354 |       await repository.initialize();
      355 |
    > 356 |       const result = await repository.findByAlias('test');
          |                                       ^
      357 |
      358 |       expect(result).toBeInstanceOf(Personality);
      359 |       expect(result.personalityId.value).toBe('test-personality');

      at findByAlias (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:356:39)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findByAlias › should find personality by alias case-insensitive

    TypeError: repository.findByAlias is not a function

      363 |       await repository.initialize();
      364 |
    > 365 |       const result = await repository.findByAlias('TEST');
          |                                       ^
      366 |
      367 |       expect(result).toBeInstanceOf(Personality);
      368 |       expect(result.personalityId.value).toBe('test-personality');

      at findByAlias (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:365:39)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findByAlias › should return null if alias not found

    TypeError: repository.findByAlias is not a function

      372 |       await repository.initialize();
      373 |
    > 374 |       const result = await repository.findByAlias('non-existent');
          |                                       ^
      375 |
      376 |       expect(result).toBeNull();
      377 |     });

      at findByAlias (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:374:39)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findByAlias › should clean up orphaned alias and return null

    TypeError: repository.findByAlias is not a function

      393 |       await repository.initialize();
      394 |
    > 395 |       const result = await repository.findByAlias('orphan');
          |                                       ^
      396 |
      397 |       expect(result).toBeNull();
      398 |       // Verify behavior - orphan cleaned up in subsequent finds

      at findByAlias (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:395:39)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findByAlias › should handle errors during hydration

    TypeError: repository.findByAlias is not a function

      419 |       await repository.initialize();
      420 |
    > 421 |       await expect(repository.findByAlias('bad')).rejects.toThrow(
          |                               ^
      422 |         'Failed to find personality by alias'
      423 |       );
      424 |     });

      at findByAlias (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:421:31)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findAll › should return all personalities

    expect(received).toHaveLength(expected)

    Expected length: 3
    Received length: 0
    Received array:  []

      450 |       const results = await repository.findAll();
      451 |
    > 452 |       expect(results).toHaveLength(3);
          |                       ^
      453 |       expect(results.every(p => p instanceof Personality)).toBe(true);
      454 |       expect(results.map(p => p.personalityId.value)).toEqual(['test-personality', 'test-2', 'test-3']);
      455 |     });

      at toHaveLength (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:452:23)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › findAll › should handle errors during hydration

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: []

      488 |       await repository.initialize();
      489 |
    > 490 |       await expect(repository.findAll()).rejects.toThrow(
          |             ^
      491 |         'Failed to find all personalities'
      492 |       );
      493 |     });

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:490:13)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › delete › should delete a personality and its aliases

    TypeError: repository.delete is not a function

      498 |       await repository.initialize();
      499 |
    > 500 |       await repository.delete(new PersonalityId('test-personality'));
          |                              ^
      501 |
      502 |       // Verify behavior - personality and aliases no longer found
      503 |       const personality = await repository.findById(new PersonalityId('test-personality'));

      at tests/unit/adapters/persistence/FilePersonalityRepository.test.js:500:30
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › delete › should handle deleting non-existent personality

    TypeError: repository.delete is not a function

      513 |       await repository.initialize();
      514 |
    > 515 |       await repository.delete(new PersonalityId('non-existent'));
          |                              ^
      516 |
      517 |       expect(fs.writeFile).not.toHaveBeenCalled();
      518 |     });

      at tests/unit/adapters/persistence/FilePersonalityRepository.test.js:515:30
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › delete › should handle delete errors

    TypeError: repository.delete is not a function

      522 |       fs.writeFile.mockRejectedValue(new Error('Permission denied'));
      523 |
    > 524 |       await expect(repository.delete(new PersonalityId('test-personality'))).rejects.toThrow(
          |                                     ^
      525 |         'Failed to delete personality'
      526 |       );
      527 |     });

      at tests/unit/adapters/persistence/FilePersonalityRepository.test.js:524:37
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › exists › should return true if personality exists

    TypeError: repository.exists is not a function

      532 |       await repository.initialize();
      533 |
    > 534 |       const result = await repository.exists(new PersonalityId('test-personality'));
          |                                       ^
      535 |
      536 |       expect(result).toBe(true);
      537 |     });

      at exists (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:534:39)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › exists › should return false if personality does not exist

    TypeError: repository.exists is not a function

      540 |       await repository.initialize();
      541 |
    > 542 |       const result = await repository.exists(new PersonalityId('non-existent'));
          |                                       ^
      543 |
      544 |       expect(result).toBe(false);
      545 |     });

      at exists (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:542:39)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › createBackup › should create backup file with timestamp

    TypeError: repository.createBackup is not a function

      552 |       jest.spyOn(global, 'Date').mockImplementation(() => mockDate);
      553 |
    > 554 |       const backupPath = await repository.createBackup();
          |                                           ^
      555 |
      556 |       expect(backupPath).toBe(path.join('./test-data', 'personalities-backup-2024-01-15T10-30-45-123Z.json'));
      557 |       expect(fs.writeFile).toHaveBeenCalledWith(

      at createBackup (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:554:43)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › createBackup › should handle backup errors

    TypeError: repository.createBackup is not a function

      566 |       fs.writeFile.mockRejectedValue(new Error('No space left'));
      567 |
    > 568 |       await expect(repository.createBackup()).rejects.toThrow(
          |                               ^
      569 |         'Failed to create backup: No space left'
      570 |       );
      571 |     });

      at createBackup (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:568:31)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › getStats › should return repository statistics

    TypeError: repository.getStats is not a function

      596 |       await repository.save(personality3);
      597 |
    > 598 |       const stats = await repository.getStats();
          |                                      ^
      599 |
      600 |       expect(stats).toEqual({
      601 |         totalPersonalities: 3,

      at getStats (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:598:38)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › getStats › should return zero stats for empty repository

    TypeError: repository.getStats is not a function

      611 |       await repository.initialize();
      612 |
    > 613 |       const stats = await repository.getStats();
          |                                      ^
      614 |
      615 |       expect(stats).toEqual({
      616 |         totalPersonalities: 0,

      at getStats (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:613:38)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › legacy data migration › should detect and migrate legacy format data

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "personalities.legacy.json", "{
      \"test-personality\": {
        \"fullName\": \"test-personality\",
        \"addedBy\": \"123456789012345678\",
        \"displayName\": \"Test Display\",
        \"avatarUrl\": \"https://example.com/avatar.png\",
        \"errorMessage\": \"Test error message\",
        \"lastUpdated\": \"2025-06-18T17:45:21.858Z\"
      },
      \"another-personality\": {
        \"fullName\": \"another-personality\",
        \"addedBy\": \"987654321098765432\",
        \"addedAt\": \"2025-06-01T10:00:00.000Z\",
        \"displayName\": \"Another Display\"
      }
    }"

    Number of calls: 0

      665 |
      666 |       // Verify backup was created
    > 667 |       expect(fs.writeFile).toHaveBeenCalledWith(
          |                            ^
      668 |         expect.stringContaining('personalities.legacy.json'),
      669 |         JSON.stringify(legacyData, null, 2)
      670 |       );

      at toHaveBeenCalledWith (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:667:28)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › legacy data migration › should handle missing aliases file gracefully

    TypeError: Cannot read properties of undefined (reading '1')

      725 |         call[0].endsWith('.tmp')
      726 |       );
    > 727 |       const persistedData = JSON.parse(writeCall[1]);
          |                                                 ^
      728 |
      729 |       expect(persistedData.personalities['test-personality']).toBeDefined();
      730 |       expect(persistedData.aliases).toEqual({});

      at tests/unit/adapters/persistence/FilePersonalityRepository.test.js:727:49
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › legacy data migration › should access migrated data correctly after migration

    TypeError: Cannot read properties of null (reading 'personalityId')

      777 |       const personality = await repository.findByName('test-personality');
      778 |       expect(personality).toBeDefined();
    > 779 |       expect(personality.personalityId.value).toBe('test-personality');
          |                          ^
      780 |       expect(personality.profile.displayName).toBe('Test Display');
      781 |
      782 |       // Test finding by alias

      at personalityId (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:779:26)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › hydration behavior › should handle aliases as strings

    TypeError: Cannot read properties of null (reading 'aliases')

      803 |       const retrieved = await repository.findById(new PersonalityId('test-id'));
      804 |
    > 805 |       expect(retrieved.aliases).toHaveLength(2);
          |                        ^
      806 |       expect(retrieved.aliases[0].value).toBe('alias1');
      807 |       expect(retrieved.aliases[1].value).toBe('alias2');
      808 |     });

      at aliases (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:805:24)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › hydration behavior › should handle aliases as objects

    TypeError: Cannot read properties of null (reading 'aliases')

      829 |       const personality = await repository.findById(new PersonalityId('test-id'));
      830 |
    > 831 |       expect(personality.aliases).toHaveLength(2);
          |                          ^
      832 |       expect(personality.aliases[0].value).toBe('alias1');
      833 |       expect(personality.aliases[1].value).toBe('alias2');
      834 |     });

      at aliases (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:831:26)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › hydration behavior › should handle missing profile

    TypeError: Cannot read properties of null (reading 'profile')

      856 |
      857 |       // When created, personality gets a default profile
    > 858 |       expect(personality.profile).not.toBeNull();
          |                          ^
      859 |       // Check that the profile has default values
      860 |       expect(personality.profile.name).toBe('test-id');
      861 |       expect(personality.profile.prompt).toBe('You are test-id');

      at profile (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:858:26)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › hydration behavior › should mark events as committed

    TypeError: Cannot read properties of null (reading 'getUncommittedEvents')

      877 |       const retrieved = await repository.findById(new PersonalityId('test-id'));
      878 |
    > 879 |       expect(retrieved.getUncommittedEvents()).toHaveLength(0);
          |                        ^
      880 |     });
      881 |   });
      882 |

      at getUncommittedEvents (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:879:24)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › persistence behavior › should write to temp file then rename

    expect(received).not.toBeNull()

    Received: null

      899 |       // Save operation should trigger persist
      900 |       const persistedPersonality = await repository.findById(new PersonalityId('new'));
    > 901 |       expect(persistedPersonality).not.toBeNull();
          |                                        ^
      902 |       expect(fs.writeFile).toHaveBeenCalledWith(
      903 |         tempPath,
      904 |         expect.any(String),

      at toBeNull (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:901:40)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › persistence behavior › should format JSON with indentation

    TypeError: Cannot read properties of undefined (reading '1')

      921 |       await repository.save(personality);
      922 |
    > 923 |       const writtenData = fs.writeFile.mock.calls[0][1];
          |                                                     ^
      924 |       expect(writtenData).toContain('  '); // Check for indentation
      925 |       expect(() => JSON.parse(writtenData)).not.toThrow();
      926 |     });

      at tests/unit/adapters/persistence/FilePersonalityRepository.test.js:923:53
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

  ● FilePersonalityRepository › persistence behavior › should throw specific error on failure

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: true

      938 |         AIModel.createDefault()
      939 |       );
    > 940 |       await expect(repository.save(personality)).rejects.toThrow('Failed to save personality');
          |             ^
      941 |     });
      942 |   });
      943 | });

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:940:13)
      at Generator.call (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)
      at asyncGeneratorStep (tests/unit/adapters/persistence/FilePersonalityRepository.test.js:2:1)

 FAIL  tests/unit/webhookManager.chunkDelay.test.js
  ● WebhookManager - Chunk Delay Tests › should not delay on the first chunk

    TypeError: webhookManager.setDelayFunction is not a function

      150 |       webhookManager = require('../../src/webhookManager');
      151 |       // Set our mock delay function
    > 152 |       webhookManager.setDelayFunction(mockDelayFn);
          |                      ^
      153 |
      154 |       // Mock calculateMessageDelay to return 0 (no initial delay)
      155 |       webhookManager.calculateMessageDelay = jest.fn().mockReturnValue(0);

      at setDelayFunction (tests/unit/webhookManager.chunkDelay.test.js:152:22)
      at Object.isolateModules (tests/unit/webhookManager.chunkDelay.test.js:149:10)

  ● WebhookManager - Chunk Delay Tests › should delay 750ms between chunks for multi-chunk messages

    TypeError: webhookManager.setDelayFunction is not a function

      150 |       webhookManager = require('../../src/webhookManager');
      151 |       // Set our mock delay function
    > 152 |       webhookManager.setDelayFunction(mockDelayFn);
          |                      ^
      153 |
      154 |       // Mock calculateMessageDelay to return 0 (no initial delay)
      155 |       webhookManager.calculateMessageDelay = jest.fn().mockReturnValue(0);

      at setDelayFunction (tests/unit/webhookManager.chunkDelay.test.js:152:22)
      at Object.isolateModules (tests/unit/webhookManager.chunkDelay.test.js:149:10)

  ● WebhookManager - Chunk Delay Tests › should use custom delay function when set

    TypeError: webhookManager.setDelayFunction is not a function

      150 |       webhookManager = require('../../src/webhookManager');
      151 |       // Set our mock delay function
    > 152 |       webhookManager.setDelayFunction(mockDelayFn);
          |                      ^
      153 |
      154 |       // Mock calculateMessageDelay to return 0 (no initial delay)
      155 |       webhookManager.calculateMessageDelay = jest.fn().mockReturnValue(0);

      at setDelayFunction (tests/unit/webhookManager.chunkDelay.test.js:152:22)
      at Object.isolateModules (tests/unit/webhookManager.chunkDelay.test.js:149:10)

  ● WebhookManager - Chunk Delay Tests › should apply delay for each chunk after the first

    TypeError: webhookManager.setDelayFunction is not a function

      150 |       webhookManager = require('../../src/webhookManager');
      151 |       // Set our mock delay function
    > 152 |       webhookManager.setDelayFunction(mockDelayFn);
          |                      ^
      153 |
      154 |       // Mock calculateMessageDelay to return 0 (no initial delay)
      155 |       webhookManager.calculateMessageDelay = jest.fn().mockReturnValue(0);

      at setDelayFunction (tests/unit/webhookManager.chunkDelay.test.js:152:22)
      at Object.isolateModules (tests/unit/webhookManager.chunkDelay.test.js:149:10)

  ● WebhookManager - Chunk Delay Tests › should verify exact delay timing between chunks

    TypeError: webhookManager.setDelayFunction is not a function

      150 |       webhookManager = require('../../src/webhookManager');
      151 |       // Set our mock delay function
    > 152 |       webhookManager.setDelayFunction(mockDelayFn);
          |                      ^
      153 |
      154 |       // Mock calculateMessageDelay to return 0 (no initial delay)
      155 |       webhookManager.calculateMessageDelay = jest.fn().mockReturnValue(0);

      at setDelayFunction (tests/unit/webhookManager.chunkDelay.test.js:152:22)
      at Object.isolateModules (tests/unit/webhookManager.chunkDelay.test.js:149:10)

  ● WebhookManager - Chunk Delay Tests › should handle empty content without delays

    TypeError: webhookManager.setDelayFunction is not a function

      150 |       webhookManager = require('../../src/webhookManager');
      151 |       // Set our mock delay function
    > 152 |       webhookManager.setDelayFunction(mockDelayFn);
          |                      ^
      153 |
      154 |       // Mock calculateMessageDelay to return 0 (no initial delay)
      155 |       webhookManager.calculateMessageDelay = jest.fn().mockReturnValue(0);

      at setDelayFunction (tests/unit/webhookManager.chunkDelay.test.js:152:22)
      at Object.isolateModules (tests/unit/webhookManager.chunkDelay.test.js:149:10)

  ● WebhookManager - Chunk Delay Tests › should handle delay errors gracefully

    TypeError: webhookManager.setDelayFunction is not a function

      150 |       webhookManager = require('../../src/webhookManager');
      151 |       // Set our mock delay function
    > 152 |       webhookManager.setDelayFunction(mockDelayFn);
          |                      ^
      153 |
      154 |       // Mock calculateMessageDelay to return 0 (no initial delay)
      155 |       webhookManager.calculateMessageDelay = jest.fn().mockReturnValue(0);

      at setDelayFunction (tests/unit/webhookManager.chunkDelay.test.js:152:22)
      at Object.isolateModules (tests/unit/webhookManager.chunkDelay.test.js:149:10)

 FAIL  tests/unit/application/commands/personality/AliasCommand.test.js
  ● AliasCommand › execute › should add alias successfully with embed

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "testpersonality", "newalias", "123456789"
    Received: {"alias": "newalias", "personalityName": "testpersonality", "requesterId": "123456789"}

    Number of calls: 1

      84 |       await command.execute(mockContext);
      85 |
    > 86 |       expect(mockPersonalityService.addAlias).toHaveBeenCalledWith('testpersonality', 'newalias', '123456789');
         |                                               ^
      87 |
      88 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
      89 |         expect.objectContaining({

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:86:47)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should add alias successfully without embed support

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "testpersonality", "newalias", "123456789"
    Received: {"alias": "newalias", "personalityName": "testpersonality", "requesterId": "123456789"}

    Number of calls: 1

      105 |       await command.execute(mockContext);
      106 |
    > 107 |       expect(mockPersonalityService.addAlias).toHaveBeenCalledWith('testpersonality', 'newalias', '123456789');
          |                                               ^
      108 |       expect(mockContext.respond).toHaveBeenCalledWith(
      109 |         '✅ Alias "newalias" has been added to **Test Personality**.'
      110 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:107:47)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should handle slash command options

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "testpersonality", "newalias", "123456789"
    Received: {"alias": "newalias", "personalityName": "testpersonality", "requesterId": "123456789"}

    Number of calls: 1

      122 |       await command.execute(mockContext);
      123 |
    > 124 |       expect(mockPersonalityService.addAlias).toHaveBeenCalledWith('testpersonality', 'newalias', '123456789');
          |                                               ^
      125 |     });
      126 |
      127 |     it('should require both arguments for text command', async () => {

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:124:47)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should require both arguments for text command

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "You need to provide a personality name and an alias. Usage: `!tz alias <personality-name> <new-alias>`"
    Received: {"embeds": [{"color": 2201331, "description": "Add a nickname or shortcut for an existing personality.", "fields": [{"inline": false, "name": "Basic Usage", "value": "`!tz alias <personality-name> <new-alias>`"}, {"inline": false, "name": "Examples", "value": "• `!tz alias Claude cl` - Add \"cl\" as alias for Claude
    • `!tz alias \"Assistant Bot\" helper` - Add \"helper\" as alias
    • `!tz alias MyAI ai-buddy` - Add \"ai-buddy\" as alias"}, {"inline": false, "name": "Parameters", "value": "• **personality-name**: Name or existing alias of the personality
    • **new-alias**: The new shortcut to add (letters, numbers, underscores, hyphens only)"}], "footer": {"text": "Aliases make it easier to mention personalities quickly"}, "title": "How to Add an Alias"}]}

    Number of calls: 1

      131 |
      132 |       expect(mockPersonalityService.addAlias).not.toHaveBeenCalled();
    > 133 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      134 |         'You need to provide a personality name and an alias. Usage: `!tz alias <personality-name> <new-alias>`'
      135 |       );
      136 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:133:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should validate personality name is provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Please provide a personality name or alias."
    Received: {"embeds": [{"color": 16007990, "description": "Please provide a personality name or existing alias.", "fields": [{"inline": false, "name": "What to provide", "value": "• The personality's name (e.g., \"Claude\")
    • Or an existing alias (e.g., \"cl\")"}], "title": "❌ Missing Personality Name"}]}

    Number of calls: 1

      142 |
      143 |       expect(mockPersonalityService.addAlias).not.toHaveBeenCalled();
    > 144 |       expect(mockContext.respond).toHaveBeenCalledWith('Please provide a personality name or alias.');
          |                                   ^
      145 |     });
      146 |
      147 |     it('should validate alias is provided', async () => {

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:144:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should validate alias is provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Please provide a new alias."
    Received: {"embeds": [{"color": 16007990, "description": "Please provide a new alias to add.", "fields": [{"inline": false, "name": "What to provide", "value": "A short nickname for the personality (e.g., \"helper\", \"ai-bot\", \"assistant\")"}], "title": "❌ Missing Alias"}]}

    Number of calls: 1

      151 |
      152 |       expect(mockPersonalityService.addAlias).not.toHaveBeenCalled();
    > 153 |       expect(mockContext.respond).toHaveBeenCalledWith('Please provide a new alias.');
          |                                   ^
      154 |     });
      155 |
      156 |     it('should validate alias format', async () => {

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:153:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should validate alias format

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Aliases can only contain letters, numbers, underscores, and hyphens."
    Received: {"embeds": [{"color": 16007990, "description": "Aliases can only contain letters, numbers, underscores, and hyphens.", "fields": [{"inline": false, "name": "Valid characters", "value": "• Letters (a-z, A-Z)
    • Numbers (0-9)
    • Underscores (_)
    • Hyphens (-)"}, {"inline": false, "name": "Examples", "value": "✅ `claude-ai`
    ✅ `helper_bot`
    ✅ `AI2024`
    ❌ `claude.ai`
    ❌ `helper bot`
    ❌ `AI@2024`"}], "title": "❌ Invalid Alias Format"}]}

    Number of calls: 1

      160 |
      161 |       expect(mockPersonalityService.addAlias).not.toHaveBeenCalled();
    > 162 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      163 |         'Aliases can only contain letters, numbers, underscores, and hyphens.'
      164 |       );
      165 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:162:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should handle service errors

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Alias already exists"
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while adding the alias.", "fields": [{"inline": false, "name": "What happened", "value": "Cannot read properties of undefined (reading 'displayName')"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check your command syntax
    • Verify the personality exists
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316946872"}, "timestamp": "2025-06-19T07:09:06.872Z", "title": "❌ Something Went Wrong"}]}

    Number of calls: 1

      173 |       await command.execute(mockContext);
      174 |
    > 175 |       expect(mockContext.respond).toHaveBeenCalledWith('Alias already exists');
          |                                   ^
      176 |     });
      177 |
      178 |     it('should handle personality without avatar', async () => {

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:175:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should handle personality without avatar

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectNotContaining {"thumbnail": Anything}

    Number of calls: 0

      190 |       await command.execute(mockContext);
      191 |
    > 192 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      193 |         expect.not.objectContaining({
      194 |           thumbnail: expect.anything()
      195 |         })

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:192:44)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should handle personality without display name

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"description": "An alias has been set for **testpersonality**."}

    Number of calls: 0

      210 |       await command.execute(mockContext);
      211 |
    > 212 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      213 |         expect.objectContaining({
      214 |           description: 'An alias has been set for **testpersonality**.'
      215 |         })

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:212:44)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should handle missing personality service

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "❌ An error occurred while adding the alias. Please try again later or contact support if the issue persists."
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while adding the alias.", "fields": [{"inline": false, "name": "What happened", "value": "PersonalityApplicationService not available"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check your command syntax
    • Verify the personality exists
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316946898"}, "timestamp": "2025-06-19T07:09:06.898Z", "title": "❌ Something Went Wrong"}]}

    Number of calls: 1

      222 |       await command.execute(mockContext);
      223 |
    > 224 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      225 |         '❌ An error occurred while adding the alias. ' +
      226 |         'Please try again later or contact support if the issue persists.'
      227 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:224:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should handle service exceptions

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "❌ An error occurred while adding the alias. Please try again later or contact support if the issue persists."
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while adding the alias.", "fields": [{"inline": false, "name": "What happened", "value": "Service error"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check your command syntax
    • Verify the personality exists
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316946905"}, "timestamp": "2025-06-19T07:09:06.905Z", "title": "❌ Something Went Wrong"}]}

    Number of calls: 1

      233 |       await command.execute(mockContext);
      234 |
    > 235 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      236 |         '❌ An error occurred while adding the alias. ' +
      237 |         'Please try again later or contact support if the issue persists.'
      238 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:235:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should lowercase input arguments

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "testpersonality", "newalias", "123456789"
    Received: {"alias": "newalias", "personalityName": "testpersonality", "requesterId": "123456789"}

    Number of calls: 1

      244 |       await command.execute(mockContext);
      245 |
    > 246 |       expect(mockPersonalityService.addAlias).toHaveBeenCalledWith('testpersonality', 'newalias', '123456789');
          |                                               ^
      247 |     });
      248 |
      249 |     it('should use default bot prefix when not provided', async () => {

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:246:47)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

  ● AliasCommand › execute › should use default bot prefix when not provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "`!tz alias"
    Received: {"embeds": [{"color": 2201331, "description": "Add a nickname or shortcut for an existing personality.", "fields": [{"inline": false, "name": "Basic Usage", "value": "`!tz alias <personality-name> <new-alias>`"}, {"inline": false, "name": "Examples", "value": "• `!tz alias Claude cl` - Add \"cl\" as alias for Claude
    • `!tz alias \"Assistant Bot\" helper` - Add \"helper\" as alias
    • `!tz alias MyAI ai-buddy` - Add \"ai-buddy\" as alias"}, {"inline": false, "name": "Parameters", "value": "• **personality-name**: Name or existing alias of the personality
    • **new-alias**: The new shortcut to add (letters, numbers, underscores, hyphens only)"}], "footer": {"text": "Aliases make it easier to mention personalities quickly"}, "title": "How to Add an Alias"}]}

    Number of calls: 1

      253 |       await command.execute(mockContext);
      254 |
    > 255 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      256 |         expect.stringContaining('`!tz alias')
      257 |       );
      258 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AliasCommand.test.js:255:35)
      at Generator.call (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AliasCommand.test.js:2:1)

 FAIL  tests/unit/application/commands/personality/ListCommand.test.js
  ● ListCommand › execute › should list personalities successfully with embed

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"author": {"icon_url": "https://example.com/user.png", "name": "TestUser"}, "color": 48340, "description": "You have added 3 personalities.", "fields": [{"inline": false, "name": "1. First Personality", "value": "Name: `personality1`
    Aliases: p1, first"}, {"inline": false, "name": "2. Second Personality", "value": "Name: `personality2`
    Aliases: None"}, {"inline": false, "name": "3. personality3", "value": "Name: `personality3`
    Aliases: p3"}], "footer": {"icon_url": "https://example.com/user.png", "text": "Page 1 of 1"}, "title": "Your Personalities (Page 1/1)"}

    Number of calls: 0

      100 |       expect(mockPersonalityService.listPersonalitiesByOwner).toHaveBeenCalledWith('123456789');
      101 |
    > 102 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      103 |         expect.objectContaining({
      104 |           title: 'Your Personalities (Page 1/1)',
      105 |           description: 'You have added 3 personalities.',

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:102:44)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should list personalities successfully without embed support

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "**Your Personalities (Page 1/1)**
    You have added 3 personalities.·
    **1. First Personality**
       Name: `personality1`
       Aliases: p1, first·
    **2. Second Personality**
       Name: `personality2`
       Aliases: None·
    **3. personality3**
       Name: `personality3`
       Aliases: p3·
    "
    Received: {"embeds": [{"color": 2201331, "description": "Showing 3 of 3 personalities", "fields": [{"inline": false, "name": "1. First Personality", "value": "**Name:** `personality1`
    **Aliases:** p1, first"}, {"inline": false, "name": "2. Second Personality", "value": "**Name:** `personality2`
    **Aliases:** None"}, {"inline": false, "name": "3. personality3", "value": "**Name:** `personality3`
    **Aliases:** p3"}], "footer": {"text": "Page 1 of 1"}, "timestamp": "2025-06-19T07:09:09.326Z", "title": "�� Your Personalities"}]}

    Number of calls: 1

      139 |       await command.execute(mockContext);
      140 |
    > 141 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      142 |         '**Your Personalities (Page 1/1)**\n' +
      143 |         'You have added 3 personalities.\n\n' +
      144 |         '**1. First Personality**\n' +

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:141:35)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle pagination

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"description": StringContaining "You have added 15 personalities.", "fields": ArrayContaining [ObjectContaining {"name": "11. Personality 11"}, ObjectContaining {"name": "12. Personality 12"}, ObjectContaining {"name": "13. Personality 13"}, ObjectContaining {"name": "14. Personality 14"}, ObjectContaining {"name": "15. Personality 15"}], "footer": ObjectContaining {"text": "Page 2 of 2"}, "title": "Your Personalities (Page 2/2)"}

    Number of calls: 0

      169 |       await command.execute(mockContext);
      170 |
    > 171 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      172 |         expect.objectContaining({
      173 |           title: 'Your Personalities (Page 2/2)',
      174 |           description: expect.stringContaining('You have added 15 personalities.'),

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:171:44)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle no personalities

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "You haven't added any personalities yet. Use `!tz add <personality-name>` to add one."
    Received: {"embeds": [{"color": 16750592, "description": "You haven't added any personalities.", "fields": [{"inline": false, "name": "Get Started", "value": "Use `!tz add <personality-name>` to create your first personality!"}, {"inline": false, "name": "Example", "value": "`!tz add Claude \"You are Claude, a helpful AI assistant\"`"}], "footer": {"text": "Personalities allow you to create custom AI assistants"}, "title": "�� No Personalities Yet"}]}

    Number of calls: 1

      199 |       await command.execute(mockContext);
      200 |
    > 201 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      202 |         "You haven't added any personalities yet. Use `!tz add <personality-name>` to add one."
      203 |       );
      204 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:201:35)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle invalid page number

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Invalid page number. Please specify a page between 1 and 1."
    Received: {"embeds": [{"color": 16007990, "description": "The page number you specified is out of range.", "fields": [{"inline": true, "name": "Valid Range", "value": "Pages 1 to 1"}, {"inline": true, "name": "You Entered", "value": "5"}, {"inline": true, "name": "Total Personalities", "value": "3"}], "title": "❌ Invalid Page Number"}]}

    Number of calls: 1

      209 |       await command.execute(mockContext);
      210 |
    > 211 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      212 |         'Invalid page number. Please specify a page between 1 and 1.'
      213 |       );
      214 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:211:35)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle non-numeric page argument

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"title": "Your Personalities (Page 1/1)"}

    Number of calls: 0

      220 |
      221 |       // Should default to page 1
    > 222 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      223 |         expect.objectContaining({
      224 |           title: 'Your Personalities (Page 1/1)'
      225 |         })

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:222:44)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should show pagination hint for multiple pages

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"description": StringContaining "Use `!tz list <page>` to view other pages."}

    Number of calls: 0

      237 |       await command.execute(mockContext);
      238 |
    > 239 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      240 |         expect.objectContaining({
      241 |           description: expect.stringContaining('Use `!tz list <page>` to view other pages.')
      242 |         })

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:239:44)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle missing personality service

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "❌ An error occurred while listing personalities. Please try again later or contact support if the issue persists."
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while listing personalities.", "fields": [{"inline": false, "name": "What happened", "value": "PersonalityApplicationService not available"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Use the command without a page number
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316949364"}, "timestamp": "2025-06-19T07:09:09.364Z", "title": "❌ Something Went Wrong"}]}

    Number of calls: 1

      249 |       await command.execute(mockContext);
      250 |
    > 251 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      252 |         '❌ An error occurred while listing personalities. ' +
      253 |         'Please try again later or contact support if the issue persists.'
      254 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:251:35)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle service exceptions

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "❌ An error occurred while listing personalities. Please try again later or contact support if the issue persists."
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while listing personalities.", "fields": [{"inline": false, "name": "What happened", "value": "Service error"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Use the command without a page number
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316949370"}, "timestamp": "2025-06-19T07:09:09.370Z", "title": "❌ Something Went Wrong"}]}

    Number of calls: 1

      260 |       await command.execute(mockContext);
      261 |
    > 262 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      263 |         '❌ An error occurred while listing personalities. ' +
      264 |         'Please try again later or contact support if the issue persists.'
      265 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:262:35)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle single personality correctly

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"description": "You have added 1 personality."}

    Number of calls: 0

      276 |       await command.execute(mockContext);
      277 |
    > 278 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      279 |         expect.objectContaining({
      280 |           description: 'You have added 1 personality.'
      281 |         })

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:278:44)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should use default bot prefix when not provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "`!tz add"
    Received: {"embeds": [{"color": 16750592, "description": "You haven't added any personalities.", "fields": [{"inline": false, "name": "Get Started", "value": "Use `!tz add <personality-name>` to create your first personality!"}, {"inline": false, "name": "Example", "value": "`!tz add Claude \"You are Claude, a helpful AI assistant\"`"}], "footer": {"text": "Personalities allow you to create custom AI assistants"}, "title": "�� No Personalities Yet"}]}

    Number of calls: 1

      289 |       await command.execute(mockContext);
      290 |
    > 291 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      292 |         expect.stringContaining('`!tz add')
      293 |       );
      294 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:291:35)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should handle null page in slash command

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"title": "Your Personalities (Page 1/1)"}

    Number of calls: 0

      301 |
      302 |       // Should default to page 1
    > 303 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      304 |         expect.objectContaining({
      305 |           title: 'Your Personalities (Page 1/1)'
      306 |         })

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:303:44)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

  ● ListCommand › execute › should parse page number as integer

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"title": "Your Personalities (Page 1/1)"}

    Number of calls: 0

      314 |
      315 |       // Should parse to 1
    > 316 |       expect(mockContext.respondWithEmbed).toHaveBeenCalledWith(
          |                                            ^
      317 |         expect.objectContaining({
      318 |           title: 'Your Personalities (Page 1/1)'
      319 |         })

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/ListCommand.test.js:316:44)
      at Generator.call (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/ListCommand.test.js:2:1)

 FAIL  tests/unit/application/commands/personality/RemoveCommand.test.js
  ● RemoveCommand › execute › should remove personality successfully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"content": StringContaining "✅ **Test Personality** has been removed", "embeds": ArrayContaining [ObjectContaining {"color": 16007990, "title": "Personality Removed"}]}
    Received: {"embeds": [{"color": 16007990, "description": "**Test Personality** has been removed from your collection.", "fields": [{"inline": true, "name": "Removed Personality", "value": "Test Personality"}, {"inline": false, "name": "What Now?", "value": "• You can recreate this personality with the same name
    • Use `list` to see your remaining personalities
    • The personality's conversation history has been preserved"}], "footer": {"text": "This action cannot be undone"}, "timestamp": "2025-06-19T07:09:10.731Z", "title": "✅ Personality Removed Successfully"}]}

    Number of calls: 1

       98 |       expect(mockMessageTracker.removeCompletedAddCommand).toHaveBeenCalledWith('123456789', 'testpersonality');
       99 |
    > 100 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      101 |         expect.objectContaining({
      102 |           content: expect.stringContaining('✅ **Test Personality** has been removed'),
      103 |           embeds: expect.arrayContaining([

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/RemoveCommand.test.js:100:35)
      at Generator.call (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)

  ● RemoveCommand › execute › should handle missing personality name

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "You need to provide a personality name"
    Received: {"embeds": [{"color": 2201331, "description": "Remove a personality from your collection.", "fields": [{"inline": false, "name": "Basic Usage", "value": "`!tz remove <name>`"}, {"inline": false, "name": "Examples", "value": "• `!tz remove Claude` - Remove by name
    • `!tz remove cl` - Remove by alias
    • `!tz remove \"My Assistant\"` - Remove with spaces"}, {"inline": false, "name": "Important", "value": "⚠️ You can only remove personalities you created
    ⚠️ This action cannot be undone"}], "footer": {"text": "Removed personalities can be recreated with the same name"}, "title": "How to Remove a Personality"}]}

    Number of calls: 1

      117 |       await command.execute(mockContext);
      118 |
    > 119 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      120 |         expect.stringContaining('You need to provide a personality name')
      121 |       );
      122 |       expect(mockPersonalityService.removePersonality).not.toHaveBeenCalled();

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/RemoveCommand.test.js:119:35)
      at Generator.call (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)

  ● RemoveCommand › execute › should handle personality not found error

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "not found"
    Received: {"embeds": [{"color": 16007990, "description": "No personality found with the name or alias \"testpersonality\".", "fields": [{"inline": false, "name": "What to check", "value": "• Spelling of the personality name
    • Try using the full name instead of alias
    • Use `list` command to see your personalities"}], "footer": {"text": "Personality names are case-insensitive"}, "title": "❌ Personality Not Found"}]}

    Number of calls: 1

      141 |       await command.execute(mockContext);
      142 |
    > 143 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      144 |         expect.stringContaining('not found')
      145 |       );
      146 |       expect(mockPersonalityService.removePersonality).not.toHaveBeenCalled();

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/RemoveCommand.test.js:143:35)
      at Generator.call (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)

  ● RemoveCommand › execute › should handle permission error

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "cannot remove a personality that you didn't create"
    Received: {"embeds": [{"color": 16007990, "description": "You cannot remove a personality that you didn't create.", "fields": [{"inline": false, "name": "Why this happened", "value": "• You are not the owner of this personality
    • Only the creator can remove a personality"}, {"inline": false, "name": "What you can do", "value": "• Use `list` to see personalities you own
    • Ask the owner to remove it
    • Create your own version with a different name"}], "title": "❌ Permission Denied"}]}

    Number of calls: 1

      154 |       await command.execute(mockContext);
      155 |
    > 156 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      157 |         expect.stringContaining('cannot remove a personality that you didn\'t create')
      158 |       );
      159 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/RemoveCommand.test.js:156:35)
      at Generator.call (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)

  ● RemoveCommand › execute › should handle authentication error

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Authentication failed"
    Received: {"embeds": [{"color": 16750592, "description": "You need to authenticate before removing personalities.", "fields": [{"inline": false, "name": "How to authenticate", "value": "1. Use `!tz auth` to start authentication
    2. Follow the instructions in the DM
    3. Try removing the personality again"}], "footer": {"text": "Authentication ensures secure personality management"}, "title": "❌ Authentication Required"}]}

    Number of calls: 1

      166 |       await command.execute(mockContext);
      167 |
    > 168 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      169 |         expect.stringContaining('Authentication failed')
      170 |       );
      171 |       expect(mockContext.respond).toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/RemoveCommand.test.js:168:35)
      at Generator.call (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)

  ● RemoveCommand › execute › should handle general errors

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "An error occurred"
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while removing the personality.", "fields": [{"inline": false, "name": "What happened", "value": "Database error"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check the personality name
    • Verify you own the personality
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316950776"}, "timestamp": "2025-06-19T07:09:10.776Z", "title": "❌ Something Went Wrong"}]}

    Number of calls: 1

      181 |       await command.execute(mockContext);
      182 |
    > 183 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      184 |         expect.stringContaining('An error occurred')
      185 |       );
      186 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/RemoveCommand.test.js:183:35)
      at Generator.call (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)

  ● RemoveCommand › execute › should handle missing personality service

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "An error occurred"
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while removing the personality.", "fields": [{"inline": false, "name": "What happened", "value": "PersonalityApplicationService not available"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check the personality name
    • Verify you own the personality
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316950788"}, "timestamp": "2025-06-19T07:09:10.788Z", "title": "❌ Something Went Wrong"}]}

    Number of calls: 1

      191 |       await command.execute(mockContext);
      192 |
    > 193 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      194 |         expect.stringContaining('An error occurred')
      195 |       );
      196 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/RemoveCommand.test.js:193:35)
      at Generator.call (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/RemoveCommand.test.js:2:1)

 FAIL  tests/unit/webhookManager.media.test.js
  ● Webhook Manager - Media Handling › should send message with files through webhook

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"content": "Check out this content", "username": "Test Personality"}

    Number of calls: 0

      68 |     );
      69 |
    > 70 |     expect(mockWebhook.send).toHaveBeenCalledWith(
         |                              ^
      71 |       expect.objectContaining({
      72 |         content: 'Check out this content',
      73 |         username: 'Test Personality'

      at toHaveBeenCalledWith (tests/unit/webhookManager.media.test.js:70:30)
      at Generator.call (tests/unit/webhookManager.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)

  ● Webhook Manager - Media Handling › should send message with single file through webhook

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"content": "Multiple files", "username": "Test Personality"}

    Number of calls: 0

       96 |     await promise;
       97 |
    >  98 |     expect(mockWebhook.send).toHaveBeenCalledWith(
          |                              ^
       99 |       expect.objectContaining({
      100 |         content: 'Multiple files',
      101 |         username: 'Test Personality'

      at toHaveBeenCalledWith (tests/unit/webhookManager.media.test.js:98:30)
      at Generator.call (tests/unit/webhookManager.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)

  ● Webhook Manager - Media Handling › should handle DM channels without webhooks

    expect(jest.fn()).toHaveBeenCalled()

    Expected number of calls: >= 1
    Received number of calls:    0

      123 |
      124 |     // In DMs, it should use channel.send instead of webhook
    > 125 |     expect(mockChannel.send).toHaveBeenCalled();
          |                              ^
      126 |     expect(mockWebhook.send).not.toHaveBeenCalled();
      127 |   });
      128 |

      at toHaveBeenCalled (tests/unit/webhookManager.media.test.js:125:30)
      at Generator.call (tests/unit/webhookManager.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)

  ● Webhook Manager - Media Handling › should handle empty content with files

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"files": ArrayContaining [ObjectContaining {"attachment": "https://example.com/image.png"}], "username": "Test Personality"}

    Number of calls: 0

      146 |     await promise;
      147 |
    > 148 |     expect(mockWebhook.send).toHaveBeenCalledWith(
          |                              ^
      149 |       expect.objectContaining({
      150 |         username: 'Test Personality',
      151 |         files: expect.arrayContaining([

      at toHaveBeenCalledWith (tests/unit/webhookManager.media.test.js:148:30)
      at Generator.call (tests/unit/webhookManager.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)

  ● Webhook Manager - Media Handling › should send simple message without options

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"content": "Message with embed", "username": "Test Personality"}

    Number of calls: 0

      173 |     await promise;
      174 |
    > 175 |     expect(mockWebhook.send).toHaveBeenCalledWith(
          |                              ^
      176 |       expect.objectContaining({
      177 |         content: 'Message with embed',
      178 |         username: 'Test Personality'

      at toHaveBeenCalledWith (tests/unit/webhookManager.media.test.js:175:30)
      at Generator.call (tests/unit/webhookManager.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)

  ● Webhook Manager - Media Handling › should handle errors gracefully

    expect(received).rejects.toThrow()

    Received promise resolved instead of rejected
    Resolved to value: {}

      184 |     mockWebhook.send.mockRejectedValue(new Error('Webhook error'));
      185 |
    > 186 |     const promise = expect(
          |                     ^
      187 |       webhookManager.sendWebhookMessage(
      188 |         mockChannel,
      189 |         'This will fail',

      at expect (node_modules/expect/build/index.js:113:15)
      at expect (tests/unit/webhookManager.media.test.js:186:21)
      at Generator.call (tests/unit/webhookManager.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.media.test.js:2:1)
      at _next (tests/unit/webhookManager.media.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.media.test.js:2:1)

 FAIL  tests/unit/application/commands/personality/InfoCommand.test.js
  ● InfoCommand › execute › should display personality info successfully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"embeds": ArrayContaining [ObjectContaining {"color": 2201331, "description": StringContaining "Test Personality", "fields": ArrayContaining [ObjectContaining {"name": "Full Name", "value": "testpersonality"}, ObjectContaining {"name": "Display Name", "value": "Test Personality"}, ObjectContaining {"name": "Aliases", "value": "test, testy"}, ObjectContaining {"name": "Created By", "value": "<@123456789>"}], "thumbnail": {"url": "https://example.com/avatar.png"}, "title": "Personality Info"}]}
    Received: "❌ An error occurred while getting personality info. Please try again later or contact support if the issue persists."

    Number of calls: 1

      76 |       expect(mockPersonalityService.getPersonality).toHaveBeenCalledWith('testpersonality');
      77 |
    > 78 |       expect(mockContext.respond).toHaveBeenCalledWith(
         |                                   ^
      79 |         expect.objectContaining({
      80 |           embeds: expect.arrayContaining([
      81 |             expect.objectContaining({

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/InfoCommand.test.js:78:35)
      at Generator.call (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)

  ● InfoCommand › execute › should show new system indicator when feature flag enabled

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"embeds": ArrayContaining [ObjectContaining {"fields": ArrayContaining [ObjectContaining {"name": "System", "value": "�� Using new DDD system"}]}]}
    Received: "❌ An error occurred while getting personality info. Please try again later or contact support if the issue persists."

    Number of calls: 1

      101 |       await command.execute(mockContext);
      102 |
    > 103 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      104 |         expect.objectContaining({
      105 |           embeds: expect.arrayContaining([
      106 |             expect.objectContaining({

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/InfoCommand.test.js:103:35)
      at Generator.call (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)

  ● InfoCommand › execute › should handle personality without aliases

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"embeds": ArrayContaining [ObjectContaining {"fields": ArrayContaining [ObjectContaining {"name": "Aliases", "value": "None set"}]}]}
    Received: "❌ An error occurred while getting personality info. Please try again later or contact support if the issue persists."

    Number of calls: 1

      157 |       await command.execute(mockContext);
      158 |
    > 159 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      160 |         expect.objectContaining({
      161 |           embeds: expect.arrayContaining([
      162 |             expect.objectContaining({

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/InfoCommand.test.js:159:35)
      at Generator.call (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)

  ● InfoCommand › execute › should handle personality without display name

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"embeds": ArrayContaining [ObjectContaining {"description": StringContaining "nodisplay", "fields": ArrayContaining [ObjectContaining {"name": "Display Name", "value": "Not set"}]}]}
    Received: "❌ An error occurred while getting personality info. Please try again later or contact support if the issue persists."

    Number of calls: 1

      180 |       await command.execute(mockContext);
      181 |
    > 182 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      183 |         expect.objectContaining({
      184 |           embeds: expect.arrayContaining([
      185 |             expect.objectContaining({

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/InfoCommand.test.js:182:35)
      at Generator.call (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/InfoCommand.test.js:2:1)

 FAIL  tests/unit/application/commands/authentication/VerifyCommand.test.js
  ● VerifyCommand › DM channel handling › should explain verification requirements when run in DM

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Age Verification Required"
    Received: {"embeds": [{"color": 16750592, "description": "This command must be run in a server channel marked as NSFW to verify your age.", "fields": [{"inline": false, "name": "Why NSFW channel?", "value": "Discord's age verification system uses NSFW channel access to confirm age requirements."}, {"inline": false, "name": "How to verify", "value": "1. Join a Discord server
    2. Find an NSFW-marked channel
    3. Run `!tz verify` there"}, {"inline": false, "name": "What happens after?", "value": "Once verified, you can use AI personalities in Direct Messages."}], "footer": {"text": "This is a one-time verification process"}, "timestamp": "2025-06-19T07:09:14.369Z", "title": "⚠️ Age Verification Required"}]}

    Number of calls: 1

      79 |       await verifyCommand.execute(mockContext);
      80 |
    > 81 |       expect(mockContext.respond).toHaveBeenCalledWith(
         |                                   ^
      82 |         expect.stringContaining('Age Verification Required')
      83 |       );
      84 |       expect(mockContext.respond).toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:81:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › already verified users › should inform already verified users

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Already Verified"
    Received: {"embeds": [{"color": 5025616, "description": "You are already verified to access AI personalities in Direct Messages.", "fields": [{"inline": true, "name": "Status", "value": "Age verification complete"}, {"inline": true, "name": "DM Access", "value": "Enabled"}, {"inline": false, "name": "What now?", "value": "You can use any AI personality in Direct Messages without restrictions."}], "timestamp": "2025-06-19T07:09:14.394Z", "title": "✅ Already Verified"}]}

    Number of calls: 1

      94 |       await verifyCommand.execute(mockContext);
      95 |
    > 96 |       expect(mockContext.respond).toHaveBeenCalledWith(
         |                                   ^
      97 |         expect.stringContaining('Already Verified')
      98 |       );
      99 |       expect(mockAuth.storeNsfwVerification).not.toHaveBeenCalled();

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:96:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › NSFW channel verification › should verify user in NSFW channel

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Verification Successful"
    Received: {"embeds": [{"color": 5025616, "description": "You have been successfully verified to use AI personalities in Direct Messages.", "fields": [{"inline": false, "name": "What does this mean?", "value": "You've confirmed you meet Discord's age requirements for NSFW content."}, {"inline": false, "name": "DM Access", "value": "You can now use all AI personalities in Direct Messages."}, {"inline": false, "name": "Verification method", "value": "NSFW channel access confirmed"}], "footer": {"text": "This verification is permanent"}, "timestamp": "2025-06-19T07:09:14.397Z", "title": "✅ Verification Successful"}]}

    Number of calls: 1

      108 |
      109 |       expect(mockAuth.storeNsfwVerification).toHaveBeenCalledWith('user123', true);
    > 110 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      111 |         expect.stringContaining('Verification Successful')
      112 |       );
      113 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:110:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › NSFW channel verification › should handle verification storage failure

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Verification Error"
    Received: {"embeds": [{"color": 16007990, "description": "There was an error storing your verification status.", "fields": [{"inline": false, "name": "What happened?", "value": "The verification check passed, but we couldn't save your status."}, {"inline": false, "name": "What to do", "value": "• Try the command again
    • Contact support if the issue persists"}], "timestamp": "2025-06-19T07:09:14.399Z", "title": "❌ Verification Error"}]}

    Number of calls: 1

      119 |       await verifyCommand.execute(mockContext);
      120 |
    > 121 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      122 |         expect.stringContaining('Verification Error')
      123 |       );
      124 |       expect(mockContext.respond).toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:121:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › NSFW channel access check › should verify user with access to other NSFW channels

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Verification Successful"
    Received: {"embeds": [{"color": 5025616, "description": "You have been successfully verified to use AI personalities in Direct Messages.", "fields": [{"inline": false, "name": "Verification confirmed", "value": "You meet Discord's age requirements for NSFW content."}, {"inline": false, "name": "NSFW channels you can access", "value": "<#nsfw-channel-123>"}, {"inline": false, "name": "Pro tip", "value": "Next time, run this command in one of these NSFW channels for instant verification."}], "footer": {"text": "Verification complete"}, "timestamp": "2025-06-19T07:09:14.403Z", "title": "✅ Verification Successful"}]}

    Number of calls: 1

      158 |
      159 |       expect(mockAuth.storeNsfwVerification).toHaveBeenCalledWith('user123', true);
    > 160 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      161 |         expect.stringContaining('Verification Successful')
      162 |       );
      163 |       expect(mockContext.respond).toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:160:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › NSFW channel access check › should deny verification when no NSFW channels accessible

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Unable to Verify"
    Received: {"embeds": [{"color": 16750592, "description": "Age verification requires access to NSFW channels.", "fields": [{"inline": false, "name": "Current situation", "value": "• This channel is not marked as NSFW
    • You don't have access to any NSFW channels in this server"}, {"inline": false, "name": "What you need", "value": "Access to at least one NSFW-marked channel to verify your age."}, {"inline": false, "name": "Solutions", "value": "• Ask a server admin for NSFW channel access
    • Try in a different server where you have NSFW access
    • Join a server with public NSFW channels"}], "footer": {"text": "NSFW access confirms age requirements"}, "timestamp": "2025-06-19T07:09:14.406Z", "title": "⚠️ Unable to Verify"}]}

    Number of calls: 1

      181 |
      182 |       expect(mockAuth.storeNsfwVerification).not.toHaveBeenCalled();
    > 183 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      184 |         expect.stringContaining('Unable to Verify')
      185 |       );
      186 |       expect(mockContext.respond).toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:183:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › NSFW channel access check › should handle missing guild information

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Verification Error"
    Received: {"embeds": [{"color": 16007990, "description": "Unable to verify server information.", "fields": [{"inline": false, "name": "Issue", "value": "Cannot access server data from this context."}, {"inline": false, "name": "Solution", "value": "Please try again in a regular server channel (not a thread or forum)."}], "timestamp": "2025-06-19T07:09:14.409Z", "title": "❌ Verification Error"}]}

    Number of calls: 1

      194 |       await verifyCommand.execute(mockContext);
      195 |
    > 196 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      197 |         expect.stringContaining('Verification Error')
      198 |       );
      199 |       expect(mockContext.respond).toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:196:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › NSFW channel access check › should handle channel permission check errors

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Verification Error"
    Received: {"embeds": [{"color": 16007990, "description": "An error occurred while checking NSFW channel access.", "fields": [{"inline": false, "name": "Error details", "value": "Permission check failed"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Make sure you're in a regular server channel
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316954412"}, "timestamp": "2025-06-19T07:09:14.412Z", "title": "❌ Verification Error"}]}

    Number of calls: 1

      216 |       await verifyCommand.execute(mockContext);
      217 |
    > 218 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      219 |         expect.stringContaining('Verification Error')
      220 |       );
      221 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:218:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › storage verification › should handle verification storage error in NSFW channel list

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Verification Error"
    Received: {"embeds": [{"color": 16007990, "description": "There was an error storing your verification status.", "fields": [{"inline": false, "name": "What happened?", "value": "The verification check passed, but we couldn't save your status."}, {"inline": false, "name": "What to do", "value": "• Try the command again
    • Contact support if the issue persists"}], "timestamp": "2025-06-19T07:09:14.416Z", "title": "❌ Verification Error"}]}

    Number of calls: 1

      239 |       await verifyCommand.execute(mockContext);
      240 |
    > 241 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      242 |         expect.stringContaining('Verification Error')
      243 |       );
      244 |       expect(mockContext.respond).toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:241:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › error handling › should handle unexpected errors gracefully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "An unexpected error occurred"
    Received: {"embeds": [{"color": 16007990, "description": "An unexpected error occurred during the verification process.", "fields": [{"inline": false, "name": "Error details", "value": "Database error"}, {"inline": false, "name": "What to do", "value": "• Try again in a few moments
    • Check your internet connection
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316954420"}, "timestamp": "2025-06-19T07:09:14.420Z", "title": "❌ Unexpected Error"}]}

    Number of calls: 1

      256 |       await verifyCommand.execute(mockContext);
      257 |
    > 258 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      259 |         expect.stringContaining('An unexpected error occurred')
      260 |       );
      261 |       expect(logger.error).toHaveBeenCalled();

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:258:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › channel accessibility › should only count channels user can view

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "<#visible-nsfw-123>"
    Received: {"embeds": [{"color": 5025616, "description": "You have been successfully verified to use AI personalities in Direct Messages.", "fields": [{"inline": false, "name": "Verification confirmed", "value": "You meet Discord's age requirements for NSFW content."}, {"inline": false, "name": "NSFW channels you can access", "value": "<#visible-nsfw-123>"}, {"inline": false, "name": "Pro tip", "value": "Next time, run this command in one of these NSFW channels for instant verification."}], "footer": {"text": "Verification complete"}, "timestamp": "2025-06-19T07:09:14.427Z", "title": "✅ Verification Successful"}]}

    Number of calls: 1

      301 |       // Should succeed because user has access to at least one NSFW channel
      302 |       expect(mockAuth.storeNsfwVerification).toHaveBeenCalledWith('user123', true);
    > 303 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      304 |         expect.stringContaining('<#visible-nsfw-123>')
      305 |       );
      306 |       expect(mockContext.respond).not.toHaveBeenCalledWith(

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:303:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

  ● VerifyCommand › channel accessibility › should only check text-based channels

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: StringContaining "Unable to Verify"
    Received: {"embeds": [{"color": 16750592, "description": "Age verification requires access to NSFW channels.", "fields": [{"inline": false, "name": "Current situation", "value": "• This channel is not marked as NSFW
    • You don't have access to any NSFW channels in this server"}, {"inline": false, "name": "What you need", "value": "Access to at least one NSFW-marked channel to verify your age."}, {"inline": false, "name": "Solutions", "value": "• Ask a server admin for NSFW channel access
    • Try in a different server where you have NSFW access
    • Join a server with public NSFW channels"}], "footer": {"text": "NSFW access confirms age requirements"}, "timestamp": "2025-06-19T07:09:14.437Z", "title": "⚠️ Unable to Verify"}]}

    Number of calls: 1

      326 |       // Should not find any NSFW channels since voice channels don't count
      327 |       expect(mockAuth.storeNsfwVerification).not.toHaveBeenCalled();
    > 328 |       expect(mockContext.respond).toHaveBeenCalledWith(
          |                                   ^
      329 |         expect.stringContaining('Unable to Verify')
      330 |       );
      331 |     });

      at toHaveBeenCalledWith (tests/unit/application/commands/authentication/VerifyCommand.test.js:328:35)
      at Generator.call (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/authentication/VerifyCommand.test.js:2:1)

 FAIL  tests/unit/application/commands/personality/AddCommand.test.js
  ● AddCommand › text command execution › should show usage when no arguments provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "Usage: `!tz add <name> [alias] [prompt]`",
    + {"embeds": [{"color": 2201331, "description": "Create a new AI personality for your Discord server.", "fields": [{"inline": false, "name": "Basic Usage", "value": "`!tz add <name> [alias] [prompt]`"}, {"inline": false, "name": "Examples", "value": "• `!tz add Claude` - Creates Claude with default prompt
    • `!tz add Claude claude-alias` - Creates Claude with an alias
    • `!tz add Claude \"You are Claude, a helpful AI assistant\"` - Custom prompt
    • `!tz add Claude claude-alias \"You are Claude, a helpful AI assistant\"` - Alias + prompt"}, {"inline": false, "name": "Parameters", "value": "• **name** (required): The personality's name
    • **alias** (optional): A shortcut name
    • **prompt** (optional): Custom personality instructions"}], "footer": {"text": "Pro tip: Aliases make it easier to mention personalities"}, "title": "How to Add a Personality"}]},
      {},

    Number of calls: 1

      111 |       await command.execute(mockContext);
      112 |
    > 113 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      114 |         expect.stringContaining('Usage: `!tz add <name> [alias] [prompt]`'),
      115 |         {}
      116 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:113:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › text command execution › should create personality with name only

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "✅ Successfully created personality **TestBot**",
    + {"embeds": [{"color": 5025616, "description": "Your new personality **TestBot** is ready to use!", "fields": [{"inline": true, "name": "Name", "value": "TestBot"}, {"inline": true, "name": "Display Name", "value": "TestBot"}, {"inline": false, "name": "Prompt", "value": "You are TestBot"}, {"inline": true, "name": "Model", "value": "/default"}, {"inline": true, "name": "Max Words", "value": "1000"}, {"inline": true, "name": "Owner", "value": "<@user123>"}, {"inline": false, "name": "Next Steps", "value": "• Mention **@TestBot** in a channel to start chatting
    • Use `!tz alias TestBot <new-alias>` to add more aliases
    • Use `!tz info TestBot` to view personality details"}], "footer": {"text": "Tip: Personalities can have multiple aliases for easier access"}, "timestamp": "2025-06-19T07:09:18.296Z", "title": "✅ Personality Created Successfully!"}]},
      {},

    Number of calls: 1

      132 |         aliases: []
      133 |       });
    > 134 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      135 |         expect.stringContaining('✅ Successfully created personality **TestBot**'),
      136 |         {}
      137 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:134:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › text command execution › should create personality with custom prompt

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "Prompt: \"You are a helpful assistant\"",
    + {"embeds": [{"color": 5025616, "description": "Your new personality **Claude** is ready to use!", "fields": [{"inline": true, "name": "Name", "value": "TestBot"}, {"inline": true, "name": "Display Name", "value": "TestBot"}, {"inline": false, "name": "Prompt", "value": "You are a helpful assistant"}, {"inline": true, "name": "Model", "value": "/default"}, {"inline": true, "name": "Max Words", "value": "1000"}, {"inline": true, "name": "Owner", "value": "<@user123>"}, {"inline": false, "name": "Next Steps", "value": "• Mention **@Claude** in a channel to start chatting
    • Use `!tz alias Claude <new-alias>` to add more aliases
    • Use `!tz info Claude` to view personality details"}], "footer": {"text": "Tip: Personalities can have multiple aliases for easier access"}, "timestamp": "2025-06-19T07:09:18.299Z", "title": "✅ Personality Created Successfully!"}]},
      {},

    Number of calls: 1

      152 |         aliases: []
      153 |       });
    > 154 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      155 |         expect.stringContaining('Prompt: "You are a helpful assistant"'),
      156 |         {}
      157 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:154:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › text command execution › should create personality with alias only

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "Alias: **tb**",
    + {"embeds": [{"color": 5025616, "description": "Your new personality **TestBot** is ready to use!", "fields": [{"inline": true, "name": "Name", "value": "TestBot"}, {"inline": true, "name": "Display Name", "value": "TestBot"}, {"inline": true, "name": "Alias", "value": "tb"}, {"inline": false, "name": "Prompt", "value": "You are TestBot"}, {"inline": true, "name": "Model", "value": "/default"}, {"inline": true, "name": "Max Words", "value": "1000"}, {"inline": true, "name": "Owner", "value": "<@user123>"}, {"inline": false, "name": "Next Steps", "value": "• Mention **@TestBot** in a channel to start chatting
    • Use `!tz alias TestBot <new-alias>` to add more aliases
    • Use `!tz info TestBot` to view personality details"}], "footer": {"text": "Tip: Personalities can have multiple aliases for easier access"}, "timestamp": "2025-06-19T07:09:18.310Z", "title": "✅ Personality Created Successfully!"}]},
      {},

    Number of calls: 1

      201 |         aliases: ['tb']
      202 |       });
    > 203 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      204 |         expect.stringContaining('Alias: **tb**'),
      205 |         {}
      206 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:203:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › text command execution › should create personality with alias and prompt

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "Alias: **tb**",
    + {"embeds": [{"color": 5025616, "description": "Your new personality **TestBot** is ready to use!", "fields": [{"inline": true, "name": "Name", "value": "TestBot"}, {"inline": true, "name": "Display Name", "value": "TestBot"}, {"inline": true, "name": "Alias", "value": "tb"}, {"inline": false, "name": "Prompt", "value": "You are a test bot"}, {"inline": true, "name": "Model", "value": "/default"}, {"inline": true, "name": "Max Words", "value": "1000"}, {"inline": true, "name": "Owner", "value": "<@user123>"}, {"inline": false, "name": "Next Steps", "value": "• Mention **@TestBot** in a channel to start chatting
    • Use `!tz alias TestBot <new-alias>` to add more aliases
    • Use `!tz info TestBot` to view personality details"}], "footer": {"text": "Tip: Personalities can have multiple aliases for easier access"}, "timestamp": "2025-06-19T07:09:18.314Z", "title": "✅ Personality Created Successfully!"}]},
      {},

    Number of calls: 1

      224 |         aliases: ['tb']
      225 |       });
    > 226 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      227 |         expect.stringContaining('Alias: **tb**'),
      228 |         {}
      229 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:226:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › text command execution › should validate alias format

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "Aliases can only contain letters, numbers, underscores, and hyphens.",
    + {"embeds": [{"color": 16007990, "description": "Aliases can only contain letters, numbers, underscores, and hyphens.", "fields": [{"inline": false, "name": "Valid characters", "value": "• Letters (a-z, A-Z)
    • Numbers (0-9)
    • Underscores (_)
    • Hyphens (-)"}, {"inline": false, "name": "Examples", "value": "✅ `claude-ai`
    ✅ `helper_bot`
    ✅ `AI2024`
    ❌ `claude.ai`
    ❌ `helper bot`
    ❌ `AI@2024`"}], "title": "❌ Invalid Alias Format"}]},
      {},

    Number of calls: 1

      254 |       await command.execute(mockContext);
      255 |
    > 256 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      257 |         'Aliases can only contain letters, numbers, underscores, and hyphens.',
      258 |         {}
      259 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:256:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › slash command execution › should create personality with alias option

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "Alias: **tb**",
    + {"embeds": [{"color": 5025616, "description": "Your new personality **TestBot** is ready to use!", "fields": [{"inline": true, "name": "Name", "value": "TestBot"}, {"inline": true, "name": "Display Name", "value": "TestBot"}, {"inline": true, "name": "Alias", "value": "tb"}, {"inline": false, "name": "Prompt", "value": "You are TestBot"}, {"inline": true, "name": "Model", "value": "/default"}, {"inline": true, "name": "Max Words", "value": "1000"}, {"inline": true, "name": "Owner", "value": "<@user123>"}, {"inline": false, "name": "Next Steps", "value": "• Mention **@TestBot** in a channel to start chatting
    • Use `!tz alias TestBot <new-alias>` to add more aliases
    • Use `!tz info TestBot` to view personality details"}], "footer": {"text": "Tip: Personalities can have multiple aliases for easier access"}, "timestamp": "2025-06-19T07:09:18.339Z", "title": "✅ Personality Created Successfully!"}]},
      {},

    Number of calls: 1

      327 |         aliases: ['tb']
      328 |       });
    > 329 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      330 |         expect.stringContaining('Alias: **tb**'),
      331 |         {}
      332 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:329:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › validation › should reject short names

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "Personality name must be at least 2 characters long.",
    + {"embeds": [{"color": 16007990, "description": "Personality name must be at least 2 characters long.", "fields": [{"inline": false, "name": "Requirements", "value": "• Minimum 2 characters
    • Maximum 50 characters
    • Can include letters, numbers, spaces"}], "title": "❌ Invalid Name"}]},
      {},

    Number of calls: 1

      341 |       await command.execute(mockContext);
      342 |
    > 343 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      344 |         'Personality name must be at least 2 characters long.',
      345 |         {}
      346 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:343:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › validation › should reject long names

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - "Personality name must be 50 characters or less.",
    + {"embeds": [{"color": 16007990, "description": "Personality name must be 50 characters or less.", "fields": [{"inline": true, "name": "Current length", "value": "51 characters"}, {"inline": true, "name": "Maximum allowed", "value": "50 characters"}], "title": "❌ Name Too Long"}]},
      {},

    Number of calls: 1

      354 |       await command.execute(mockContext);
      355 |
    > 356 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      357 |         'Personality name must be 50 characters or less.',
      358 |         {}
      359 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:356:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › error handling › should handle service not available

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "An error occurred while creating the personality",
    + {"embeds": [{"color": 16007990, "description": "An error occurred while creating the personality.", "fields": [{"inline": false, "name": "What happened", "value": "PersonalityApplicationService not available"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check your command syntax
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316958351"}, "timestamp": "2025-06-19T07:09:18.351Z", "title": "❌ Something Went Wrong"}]},
      {},

    Number of calls: 1

      369 |       await command.execute(mockContext);
      370 |
    > 371 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      372 |         expect.stringContaining('An error occurred while creating the personality'),
      373 |         {}
      374 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:371:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › error handling › should handle already exists error

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "already exists",
    + {"embeds": [{"color": 16007990, "description": "A personality named **TestBot** already exists.", "fields": [{"inline": false, "name": "What to do", "value": "• Choose a different name for your personality
    • Use `!tz remove TestBot` to delete the existing one first
    • Use `!tz info TestBot` to see who owns it"}], "footer": {"text": "Each personality must have a unique name"}, "title": "❌ Personality Already Exists"}]},
      {},

    Number of calls: 1

      387 |       await command.execute(mockContext);
      388 |
    > 389 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      390 |         expect.stringContaining('already exists'),
      391 |         {}
      392 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:389:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › error handling › should handle authentication error

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "Authentication failed",
    + {"embeds": [{"color": 16750592, "description": "You need to authenticate before creating personalities.", "fields": [{"inline": false, "name": "How to authenticate", "value": "1. Use `!tz auth` to start authentication
    2. Follow the instructions in the DM
    3. Try creating your personality again"}], "footer": {"text": "Authentication ensures secure personality management"}, "title": "❌ Authentication Required"}]},
      {},

    Number of calls: 1

      401 |       await command.execute(mockContext);
      402 |
    > 403 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      404 |         expect.stringContaining('Authentication failed'),
      405 |         {}
      406 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:403:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › error handling › should handle service failure

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "An error occurred",
    + {"embeds": [{"color": 16007990, "description": "An error occurred while creating the personality.", "fields": [{"inline": false, "name": "What happened", "value": "Service unavailable"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check your command syntax
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316958361"}, "timestamp": "2025-06-19T07:09:18.361Z", "title": "❌ Something Went Wrong"}]},
      {},

    Number of calls: 1

      415 |       await command.execute(mockContext);
      416 |
    > 417 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      418 |         expect.stringContaining('An error occurred'),
      419 |         {}
      420 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:417:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

  ● AddCommand › error handling › should handle generic errors

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

    - StringContaining "An error occurred while creating the personality",
    + {"embeds": [{"color": 16007990, "description": "An error occurred while creating the personality.", "fields": [{"inline": false, "name": "What happened", "value": "Unknown error"}, {"inline": false, "name": "What to do", "value": "• Try again in a moment
    • Check your command syntax
    • Contact support if the issue persists"}], "footer": {"text": "Error ID: 1750316958363"}, "timestamp": "2025-06-19T07:09:18.363Z", "title": "❌ Something Went Wrong"}]},
      {},

    Number of calls: 1

      433 |       await command.execute(mockContext);
      434 |
    > 435 |       expect(mockContext.reply).toHaveBeenCalledWith(
          |                                 ^
      436 |         expect.stringContaining('An error occurred while creating the personality'),
      437 |         {}
      438 |       );

      at toHaveBeenCalledWith (tests/unit/application/commands/personality/AddCommand.test.js:435:33)
      at Generator.call (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/personality/AddCommand.test.js:2:1)

 FAIL  tests/unit/webhookManager.dm.media.test.js
  ● Webhook Manager - DM Media Handling › should properly format DM messages with personality name

    TypeError: webhookManager.sendFormattedMessageInDM is not a function

      58 |
      59 |   it('should properly format DM messages with personality name', async () => {
    > 60 |     const result = await webhookManager.sendFormattedMessageInDM(
         |                                         ^
      61 |       mockChannel,
      62 |       'Hello World',
      63 |       personality

      at sendFormattedMessageInDM (tests/unit/webhookManager.dm.media.test.js:60:41)
      at Generator.call (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at _next (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.dm.media.test.js:2:1)

  ● Webhook Manager - DM Media Handling › should process media in DM messages

    TypeError: webhookManager.sendFormattedMessageInDM is not a function

      92 |     });
      93 |
    > 94 |     const result = await webhookManager.sendFormattedMessageInDM(
         |                                         ^
      95 |       mockChannel,
      96 |       'Check out this image: https://example.com/image.jpg',
      97 |       personality

      at sendFormattedMessageInDM (tests/unit/webhookManager.dm.media.test.js:94:41)
      at Generator.call (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at _next (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.dm.media.test.js:2:1)

  ● Webhook Manager - DM Media Handling › should handle splitting long messages with media attachments

    TypeError: webhookManager.sendFormattedMessageInDM is not a function

      143 |     });
      144 |
    > 145 |     const result = await webhookManager.sendFormattedMessageInDM(
          |                                         ^
      146 |       mockChannel,
      147 |       mediaMessage,
      148 |       personality

      at sendFormattedMessageInDM (tests/unit/webhookManager.dm.media.test.js:145:41)
      at Generator.call (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at _next (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.dm.media.test.js:2:1)

  ● Webhook Manager - DM Media Handling › should continue with original content if media processing fails

    TypeError: webhookManager.sendFormattedMessageInDM is not a function

      168 |     mediaHandler.processMediaUrls.mockRejectedValue(new Error('Media processing failed'));
      169 |
    > 170 |     const result = await webhookManager.sendFormattedMessageInDM(
          |                                         ^
      171 |       mockChannel,
      172 |       'Message with problematic image: https://example.com/bad-image.jpg',
      173 |       personality

      at sendFormattedMessageInDM (tests/unit/webhookManager.dm.media.test.js:170:41)
      at Generator.call (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.dm.media.test.js:2:1)
      at _next (tests/unit/webhookManager.dm.media.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.dm.media.test.js:2:1)

 FAIL  tests/unit/webhookManager.createVirtual.test.js
  ● WebhookManager - createVirtualResult › should create a virtual result with expected format

    TypeError: webhookManager.createVirtualResult is not a function

      32 |
      33 |     // Call the function we're testing
    > 34 |     const result = webhookManager.createVirtualResult(personality, channelId);
         |                                   ^
      35 |
      36 |     // Verify the returned object has the expected format
      37 |     expect(result).toHaveProperty('message');

      at Object.createVirtualResult (tests/unit/webhookManager.createVirtual.test.js:34:35)

  ● WebhookManager - createVirtualResult › should handle null personality gracefully

    TypeError: webhookManager.createVirtualResult is not a function

      50 |   it('should handle null personality gracefully', () => {
      51 |     // Call the function with null personality
    > 52 |     const result = webhookManager.createVirtualResult(null, 'test-channel-123');
         |                                   ^
      53 |
      54 |     // Verify the structure of the result
      55 |     expect(result).toHaveProperty('message');

      at Object.createVirtualResult (tests/unit/webhookManager.createVirtual.test.js:52:35)

  ● WebhookManager - createVirtualResult › should handle missing fullName property gracefully

    TypeError: webhookManager.createVirtualResult is not a function

      67 |
      68 |     // Call the function
    > 69 |     const result = webhookManager.createVirtualResult(personality, 'test-channel-123');
         |                                   ^
      70 |
      71 |     // Verify the structure of the result
      72 |     expect(result).toHaveProperty('message');

      at Object.createVirtualResult (tests/unit/webhookManager.createVirtual.test.js:69:35)

  ● WebhookManager - createVirtualResult › should generate a unique virtual ID for each call

    TypeError: webhookManager.createVirtualResult is not a function

      78 |   it('should generate a unique virtual ID for each call', () => {
      79 |     // Call the function multiple times
    > 80 |     const result1 = webhookManager.createVirtualResult(null, 'test-channel-123');
         |                                    ^
      81 |     const result2 = webhookManager.createVirtualResult(null, 'test-channel-123');
      82 |
      83 |     // Verify the IDs are different

      at Object.createVirtualResult (tests/unit/webhookManager.createVirtual.test.js:80:36)

 FAIL  tests/unit/application/commands/conversation/AutorespondCommand.test.js
  ● AutorespondCommand › status display › should show status when no action provided

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:74:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › status display › should show disabled status correctly

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:98:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › status display › should show status when explicitly requested

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:120:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › status display › should use options.action over args

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:139:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › enable action › should enable auto-response

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:159:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › enable action › should handle enable errors

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:192:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › enable action › should log successful enable

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:209:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › disable action › should disable auto-response

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:224:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › disable action › should handle disable errors

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:257:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › disable action › should log successful disable

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:274:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › invalid actions › should reject invalid action

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:289:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › invalid actions › should handle case insensitive actions

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:303:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › error handling › should handle unexpected errors gracefully

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:319:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › embed formatting › should include timestamps in all embeds

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:343:23)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

  ● AutorespondCommand › embed formatting › should include footer with help text in status embed

    TypeError: Cannot read properties of undefined (reading 'conversationManager')

      47 |   return async function execute(context) {
      48 |     const { args, options } = context;
    > 49 |     const conversationManager = context.dependencies.conversationManager;
         |                                                      ^
      50 |
      51 |     logger.info(`[AutorespondCommand] Executing for user ${context.getUserId()}`);
      52 |

      at conversationManager (src/application/commands/conversation/AutorespondCommand.js:49:54)
      at Generator.call (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Generator._invoke [as next] (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at asyncGeneratorStep (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at _next (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.<anonymous> (src/application/commands/conversation/AutorespondCommand.js:2:1)
      at Command.apply [as execute] (src/application/commands/conversation/AutorespondCommand.js:47:32)
      at execute (tests/unit/application/commands/conversation/AutorespondCommand.test.js:357:21)
      at Generator.call (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at asyncGeneratorStep (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at _next (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)
      at Object.<anonymous> (tests/unit/application/commands/conversation/AutorespondCommand.test.js:2:1)

 FAIL  tests/unit/webhookManager.username.suffix.test.js
  ● Webhook Username Suffix › should append bot suffix to display name

    TypeError: getStandardizedUsername is not a function

      24 |     };
      25 |
    > 26 |     const username = getStandardizedUsername(personality);
         |                      ^
      27 |     expect(username).toBe('Albert Einstein | Test Server');
      28 |
      29 |     // Test with inconsistent spacing in the bot tag

      at Object.getStandardizedUsername (tests/unit/webhookManager.username.suffix.test.js:26:22)

  ● Webhook Username Suffix › should handle long display names and truncate properly

    TypeError: getStandardizedUsername is not a function

      45 |     };
      46 |
    > 47 |     const username = getStandardizedUsername(personality);
         |                      ^
      48 |     const expectedSuffix = ' | Test Server';
      49 |     const maxNameLength = 29 - expectedSuffix.length;
      50 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.username.suffix.test.js:47:22)

  ● Webhook Username Suffix › should handle missing display name and use fullName

    TypeError: getStandardizedUsername is not a function

      61 |     };
      62 |
    > 63 |     const username = getStandardizedUsername(personality);
         |                      ^
      64 |     expect(username).toBe('Marie | Test Server');
      65 |   });
      66 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.username.suffix.test.js:63:22)

  ● Webhook Username Suffix › should handle null/undefined personality

    TypeError: getStandardizedUsername is not a function

      66 |
      67 |   it('should handle null/undefined personality', () => {
    > 68 |     const username = getStandardizedUsername(null);
         |                      ^
      69 |     expect(username).toBe('Bot');
      70 |   });
      71 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.username.suffix.test.js:68:22)

  ● Webhook Username Suffix › should work when bot has no suffix

    TypeError: getStandardizedUsername is not a function

      81 |     };
      82 |
    > 83 |     const username = getStandardizedUsername(personality);
         |                      ^
      84 |     expect(username).toBe('Sigmund Freud');
      85 |
      86 |     // Restore the global

      at Object.getStandardizedUsername (tests/unit/webhookManager.username.suffix.test.js:83:22)

  ● Webhook Username Suffix › should remove Discord discriminator from suffix

    TypeError: getStandardizedUsername is not a function

       99 |     };
      100 |
    > 101 |     const username = getStandardizedUsername(personality);
          |                      ^
      102 |     expect(username).toBe('Carl Jung | Test Server');
      103 |     expect(username.includes('#1234')).toBe(false);
      104 |

      at Object.getStandardizedUsername (tests/unit/webhookManager.username.suffix.test.js:101:22)

  ● Webhook Username Suffix › should work when global.tzurotClient is undefined

    TypeError: getStandardizedUsername is not a function

      124 |     };
      125 |
    > 126 |     const username = getStandardizedUsername(personality);
          |                      ^
      127 |     expect(username).toBe('Carl Jung');
      128 |
      129 |     // Restore the global

      at Object.getStandardizedUsername (tests/unit/webhookManager.username.suffix.test.js:126:22)

 FAIL  tests/unit/validateAvatarUrl.test.js
  ● validateAvatarUrl Success Test › should return true for valid image URLs

    TypeError: webhookManager.validateAvatarUrl is not a function

      81 |
      82 |     // Execute the validation
    > 83 |     const result = await webhookManager.validateAvatarUrl(validUrl);
         |                                         ^
      84 |
      85 |     // Should return true
      86 |     expect(result).toBe(true);

      at validateAvatarUrl (tests/unit/validateAvatarUrl.test.js:83:41)
      at Generator.call (tests/unit/validateAvatarUrl.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/validateAvatarUrl.test.js:2:1)
      at asyncGeneratorStep (tests/unit/validateAvatarUrl.test.js:2:1)
      at asyncGeneratorStep (tests/unit/validateAvatarUrl.test.js:2:1)
      at _next (tests/unit/validateAvatarUrl.test.js:2:1)
      at Object.<anonymous> (tests/unit/validateAvatarUrl.test.js:2:1)

 FAIL  tests/unit/webhookManager.simple.test.js
  ● WebhookManager Avatar URL Handling - Simplified Tests › validateAvatarUrl should return false for invalid URLs

    TypeError: webhookManager.validateAvatarUrl is not a function

      53 |   test('validateAvatarUrl should return false for invalid URLs', async () => {
      54 |     // Test with null URL
    > 55 |     expect(await webhookManager.validateAvatarUrl(null)).toBe(false);
         |                                 ^
      56 |
      57 |     // Test with empty URL
      58 |     expect(await webhookManager.validateAvatarUrl('')).toBe(false);

      at validateAvatarUrl (tests/unit/webhookManager.simple.test.js:55:33)
      at Generator.call (tests/unit/webhookManager.simple.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at _next (tests/unit/webhookManager.simple.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.simple.test.js:2:1)

  ● WebhookManager Avatar URL Handling - Simplified Tests › getValidAvatarUrl should return null for null input

    TypeError: webhookManager.getValidAvatarUrl is not a function

      64 |   test('getValidAvatarUrl should return null for null input', async () => {
      65 |     // This is the simplest test case that should always work
    > 66 |     expect(await webhookManager.getValidAvatarUrl(null)).toBe(null);
         |                                 ^
      67 |   });
      68 |
      69 |   test('preloadPersonalityAvatar should set null for personalities without avatarUrl', async () => {

      at getValidAvatarUrl (tests/unit/webhookManager.simple.test.js:66:33)
      at Generator.call (tests/unit/webhookManager.simple.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at _next (tests/unit/webhookManager.simple.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.simple.test.js:2:1)

  ● WebhookManager Avatar URL Handling - Simplified Tests › preloadPersonalityAvatar should set null for personalities without avatarUrl

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      75 |
      76 |     // Call the function
    > 77 |     await webhookManager.preloadPersonalityAvatar(personality);
         |                          ^
      78 |
      79 |     // Verify the avatar URL was set to null
      80 |     expect(personality.avatarUrl).toBe(null);

      at preloadPersonalityAvatar (tests/unit/webhookManager.simple.test.js:77:26)
      at Generator.call (tests/unit/webhookManager.simple.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at _next (tests/unit/webhookManager.simple.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.simple.test.js:2:1)

  ● WebhookManager Avatar URL Handling - Simplified Tests › preloadPersonalityAvatar should handle null personality gracefully

    TypeError: webhookManager.preloadPersonalityAvatar is not a function

      83 |   test('preloadPersonalityAvatar should handle null personality gracefully', async () => {
      84 |     // This should not throw any errors
    > 85 |     await expect(webhookManager.preloadPersonalityAvatar(null)).resolves.not.toThrow();
         |                                 ^
      86 |   });
      87 | });

      at preloadPersonalityAvatar (tests/unit/webhookManager.simple.test.js:85:33)
      at Generator.call (tests/unit/webhookManager.simple.test.js:2:1)
      at Generator._invoke [as next] (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at asyncGeneratorStep (tests/unit/webhookManager.simple.test.js:2:1)
      at _next (tests/unit/webhookManager.simple.test.js:2:1)
      at Object.<anonymous> (tests/unit/webhookManager.simple.test.js:2:1)


Test Suites: 32 failed, 215 passed, 247 total
Tests:       380 failed, 3941 passed, 4321 total
Snapshots:   0 total
Time:        51.16 s
Ran all test suites.