generator client {
  provider        = "prisma-client"
  output          = "../packages/common-types/src/generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

/// NOTE: All models use explicit IDs (no @default(uuid())) to enforce deterministic UUIDs.
/// This project syncs data between dev and prod - random UUIDs cause sync failures.
/// Application code MUST provide IDs using generators from deterministicUuid.ts.
/// See CLAUDE.md "Deterministic UUIDs Required" section.
model User {
  id                    String                     @id @db.Uuid
  discordId             String                     @unique @map("discord_id") @db.VarChar(20)
  username              String                     @db.VarChar(255)
  timezone              String                     @default("UTC") @db.VarChar(50)
  isSuperuser           Boolean                    @default(false) @map("is_superuser")
  /// NSFW verification status - required for DM interactions
  /// Auto-verified when user interacts with bot in an NSFW-marked channel
  nsfwVerified          Boolean                    @default(false) @map("nsfw_verified")
  nsfwVerifiedAt        DateTime?                  @map("nsfw_verified_at")
  defaultLlmConfigId    String?                    @map("default_llm_config_id") @db.Uuid
  defaultPersonaId      String?                    @map("default_persona_id") @db.Uuid
  /// JSONB config cascade defaults (user tier). Validated against ConfigOverridesSchema at runtime.
  configDefaults        Json?                      @map("config_defaults")
  createdAt             DateTime                   @default(now()) @map("created_at")
  updatedAt             DateTime                   @updatedAt @map("updated_at")
  apiKeys               UserApiKey[]
  usageLogs             UsageLog[]
  channelSettings       ChannelSettings[]
  adminSettingsUpdates  AdminSettings[]
  defaultLlmConfig      LlmConfig?                 @relation("UserDefaultLlmConfig", fields: [defaultLlmConfigId], references: [id], onDelete: SetNull)
  defaultPersona        Persona?                   @relation("UserDefaultPersona", fields: [defaultPersonaId], references: [id], onDelete: SetNull)
  ownedLlmConfigs       LlmConfig[]                @relation("LlmConfigOwner")
  ownedPersonalities    Personality[]              @relation("PersonalityOwner")
  personalityOwners     PersonalityOwner[]
  ownedPersonas         Persona[]                  @relation("PersonaOwner")
  personalityConfigs    UserPersonalityConfig[]
  personaHistoryConfigs UserPersonaHistoryConfig[]

  @@index([discordId])
  @@index([defaultLlmConfigId])
  @@index([defaultPersonaId])
  @@map("users")
}

/// Tracks API usage per user for monitoring, billing, and abuse prevention.
/// Even with BYOK, we track usage to prevent infrastructure abuse.
model UsageLog {
  id          String   @id @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  provider    String   @db.VarChar(20)
  model       String   @db.VarChar(255)
  tokensIn    Int      @map("tokens_in")
  tokensOut   Int      @map("tokens_out")
  requestType String   @map("request_type") @db.VarChar(50)
  createdAt   DateTime @default(now()) @map("created_at")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([provider]) // For admin queries filtering by provider across all users
  @@index([userId, createdAt])
  @@index([userId, provider])
  @@index([userId, provider, createdAt]) // For per-provider usage queries with date range
  @@map("usage_logs")
}

/// Global admin settings for bot-wide defaults.
/// Singleton row - only one row should exist (enforced by application code).
/// Replaces the old key-value BotSettings model with proper typed columns.
model AdminSettings {
  id             String   @id @db.Uuid
  updatedBy      String?  @map("updated_by") @db.Uuid
  /// JSONB config cascade defaults (admin tier). Validated against ConfigOverridesSchema at runtime.
  configDefaults Json?    @map("config_defaults")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  updatedByUser User? @relation(fields: [updatedBy], references: [id])

  @@map("admin_settings")
}

/// Encrypted API keys for BYOK (Bring Your Own Key) support.
/// Uses AES-256-GCM encryption with separate columns for iv, content, and tag.
model UserApiKey {
  id         String    @id @db.Uuid
  userId     String    @map("user_id") @db.Uuid
  provider   String    @default("openrouter") @db.VarChar(20)
  iv         String    @db.VarChar(32)
  content    String    @db.Text
  tag        String    @db.VarChar(32)
  isActive   Boolean   @default(true) @map("is_active")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  lastUsedAt DateTime? @map("last_used_at")
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@index([provider])
  @@map("user_api_keys")
}

model Persona {
  id                          String                     @id @db.Uuid
  name                        String                     @db.VarChar(255)
  description                 String?
  content                     String
  preferredName               String?                    @map("preferred_name") @db.VarChar(255)
  pronouns                    String?                    @db.VarChar(100)
  shareLtmAcrossPersonalities Boolean                    @default(false) @map("share_ltm_across_personalities")
  ownerId                     String                     @map("owner_id") @db.Uuid
  createdAt                   DateTime                   @default(now()) @map("created_at")
  updatedAt                   DateTime                   @updatedAt @map("updated_at")
  conversationHistory         ConversationHistory[]
  memories                    Memory[]
  owner                       User                       @relation("PersonaOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  usersWithAsDefault          User[]                     @relation("UserDefaultPersona")
  shapesPersonaMappings       ShapesPersonaMapping[]
  personalityConfigs          UserPersonalityConfig[]
  historyConfigs              UserPersonaHistoryConfig[] @relation("personaHistoryConfigs")

  @@index([ownerId])
  @@map("personas")
}

model SystemPrompt {
  id            String        @id @db.Uuid
  name          String        @db.VarChar(255)
  description   String?
  content       String
  isDefault     Boolean       @default(false) @map("is_default")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")
  personalities Personality[]

  @@index([isDefault])
  @@map("system_prompts")
}

model LlmConfig {
  id                          String                     @id @db.Uuid
  name                        String                     @db.VarChar(255)
  description                 String?
  ownerId                     String                     @map("owner_id") @db.Uuid
  isGlobal                    Boolean                    @default(false) @map("is_global")
  isDefault                   Boolean                    @default(false) @map("is_default")
  /// Default config for guest mode (users without API keys). Only one should be true.
  /// Enforced by partial unique index: llm_configs_free_default_unique (WHERE is_free_default = true)
  isFreeDefault               Boolean                    @default(false) @map("is_free_default")
  provider                    String                     @default("openrouter") @db.VarChar(20)
  model                       String                     @db.VarChar(255)
  visionModel                 String?                    @map("vision_model") @db.VarChar(255)
  /// JSONB field for provider-specific parameters (temperature, topP, topK, etc.)
  /// See AdvancedParamsSchema in common-types for validation
  advancedParameters          Json?                      @map("advanced_parameters")
  memoryScoreThreshold        Decimal?                   @map("memory_score_threshold") @db.Decimal(3, 2)
  memoryLimit                 Int?                       @map("memory_limit")
  contextWindowTokens         Int                        @default(131072) @map("context_window_tokens")
  // Context settings - typed columns for stable app config (not JSONB)
  // These control how many messages to fetch from conversation history
  /// Max messages to fetch from DB/Discord channel history (default: 50, capped at 100)
  maxMessages                 Int                        @default(50) @map("max_messages")
  /// Max age in seconds for messages (null = no limit)
  maxAge                      Int?                       @map("max_age")
  /// Max images to proactively process from extended context (default: 10, capped at 20)
  maxImages                   Int                        @default(10) @map("max_images")
  createdAt                   DateTime                   @default(now()) @map("created_at")
  updatedAt                   DateTime                   @updatedAt @map("updated_at")
  owner                       User                       @relation("LlmConfigOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  personalitiesUsingAsDefault PersonalityDefaultConfig[]
  userPersonalityConfigs      UserPersonalityConfig[]
  usersWithAsDefault          User[]                     @relation("UserDefaultLlmConfig")

  @@index([ownerId])
  @@index([isGlobal])
  @@index([isFreeDefault])
  @@map("llm_configs")
}

model PersonalityDefaultConfig {
  personalityId String      @id @unique @map("personality_id") @db.Uuid
  llmConfigId   String      @map("llm_config_id") @db.Uuid
  updatedAt     DateTime    @updatedAt @map("updated_at")
  llmConfig     LlmConfig   @relation(fields: [llmConfigId], references: [id], onDelete: Cascade)
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  @@index([llmConfigId])
  @@map("personality_default_configs")
}

model Personality {
  id                         String   @id @db.Uuid
  name                       String   @db.VarChar(255)
  displayName                String?  @map("display_name") @db.VarChar(255)
  slug                       String   @unique @db.VarChar(255)
  systemPromptId             String?  @map("system_prompt_id") @db.Uuid
  ownerId                    String   @map("owner_id") @db.Uuid
  characterInfo              String   @map("character_info")
  personalityTraits          String   @map("personality_traits")
  personalityTone            String?  @map("personality_tone")
  personalityAge             String?  @map("personality_age")
  personalityAppearance      String?  @map("personality_appearance")
  personalityLikes           String?  @map("personality_likes")
  personalityDislikes        String?  @map("personality_dislikes")
  conversationalGoals        String?  @map("conversational_goals")
  conversationalExamples     String?  @map("conversational_examples")
  customFields               Json?    @map("custom_fields")
  errorMessage               String?  @map("error_message")
  birthMonth                 Int?     @map("birth_month")
  birthDay                   Int?     @map("birth_day")
  birthYear                  Int?     @map("birth_year")
  isPublic                   Boolean  @default(true) @map("is_public")
  voiceEnabled               Boolean  @default(false) @map("voice_enabled")
  voiceSettings              Json?    @map("voice_settings")
  imageEnabled               Boolean  @default(false) @map("image_enabled")
  imageSettings              Json?    @map("image_settings")
  avatarData                 Bytes?   @map("avatar_data")
  /// JSONB config cascade defaults (personality tier). Validated against ConfigOverridesSchema at runtime.
  configDefaults             Json?    @map("config_defaults")

  createdAt             DateTime                   @default(now()) @map("created_at")
  updatedAt             DateTime                   @updatedAt @map("updated_at")
  channelSettings       ChannelSettings[]
  aliases               PersonalityAlias[]
  conversationHistory   ConversationHistory[]
  memories              Memory[]
  owner                 User                       @relation("PersonalityOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  systemPrompt          SystemPrompt?              @relation(fields: [systemPromptId], references: [id])
  defaultConfigLink     PersonalityDefaultConfig?
  owners                PersonalityOwner[]
  userConfigs           UserPersonalityConfig[]
  personaHistoryConfigs UserPersonaHistoryConfig[]

  @@index([slug])
  @@index([ownerId])
  @@map("personalities")
}

model PersonalityOwner {
  personalityId String      @map("personality_id") @db.Uuid
  userId        String      @map("user_id") @db.Uuid
  role          String      @default("owner") @db.VarChar(50)
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([personalityId, userId])
  @@index([userId])
  @@index([personalityId])
  @@map("personality_owners")
}

/// Aliases for personalities (e.g., "lily" -> lilith, "sassy" -> sarcastic)
/// Enables users to reference personalities by multiple names
model PersonalityAlias {
  id            String      @id @db.Uuid
  alias         String      @unique @db.VarChar(100)
  personalityId String      @map("personality_id") @db.Uuid
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  @@index([personalityId])
  @@map("personality_aliases")
}

/// User-specific overrides for a personality (persona, LLM config)
/// Note: STM epoch fields (lastContextReset) are in UserPersonaHistoryConfig,
/// which tracks per-persona history (user + personality + persona).
model UserPersonalityConfig {
  id               String   @id @db.Uuid
  userId           String   @map("user_id") @db.Uuid
  personalityId    String   @map("personality_id") @db.Uuid
  personaId        String?  @map("persona_id") @db.Uuid
  llmConfigId      String?  @map("llm_config_id") @db.Uuid
  /// Focus Mode: When true, LTM retrieval is disabled (memories still saved, just not retrieved)
  focusModeEnabled Boolean  @default(false) @map("focus_mode_enabled")
  /// JSONB config cascade overrides (user+personality tier). Validated against ConfigOverridesSchema at runtime.
  configOverrides  Json?    @map("config_overrides")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  llmConfig   LlmConfig?  @relation(fields: [llmConfigId], references: [id])
  persona     Persona?    @relation(fields: [personaId], references: [id])
  personality Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, personalityId])
  @@index([userId])
  @@index([personalityId])
  @@map("user_personality_configs")
}

/// Per-persona history configuration (epoch tracking for memory commands)
/// This enables each persona to have independent conversation history cutoffs
/// See ADR-003 in docs/planning/SLASH_COMMAND_ARCHITECTURE.md
model UserPersonaHistoryConfig {
  id            String   @id @db.Uuid
  userId        String   @map("user_id") @db.Uuid
  personalityId String   @map("personality_id") @db.Uuid
  personaId     String   @map("persona_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // STM Epoch System - Non-destructive conversation history filtering per-persona
  // Messages older than lastContextReset are excluded from AI context
  lastContextReset     DateTime? @map("last_context_reset")
  previousContextReset DateTime? @map("previous_context_reset") // For undo support

  persona     Persona     @relation("personaHistoryConfigs", fields: [personaId], references: [id], onDelete: Cascade)
  personality Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, personalityId, personaId])
  @@index([userId])
  @@index([personalityId])
  @@index([personaId])
  @@map("user_persona_history_configs")
}

model ConversationHistory {
  id               String         @id @db.Uuid
  channelId        String         @map("channel_id") @db.VarChar(20)
  guildId          String?        @map("guild_id") @db.VarChar(20) // Null for DMs
  personalityId    String         @map("personality_id") @db.Uuid
  personaId        String         @map("persona_id") @db.Uuid
  role             String         @db.VarChar(20)
  content          String
  tokenCount       Int?           @map("token_count") // Cached token count (null for old messages)
  discordMessageId String[]       @default([]) @map("discord_message_id") // Discord snowflake IDs for chunked messages (deduplication)
  /// Structured metadata for the message (referenced messages, attachments, etc.)
  /// Separates semantic content (in 'content') from contextual data
  /// See MessageMetadata interface in common-types for schema
  messageMetadata  Json?          @default("{}") @map("message_metadata")
  /// Soft delete timestamp - message excluded from context when set
  /// Used for opportunistic sync when Discord message is deleted
  deletedAt        DateTime?      @map("deleted_at")
  /// Last edit detected timestamp - updated during opportunistic sync
  /// when Discord message content differs from stored content
  editedAt         DateTime?      @map("edited_at")
  createdAt        DateTime       @default(now()) @map("created_at")
  persona          Persona        @relation(fields: [personaId], references: [id], onDelete: Cascade)
  personality      Personality    @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  pendingMemory    PendingMemory?

  @@index([channelId, personalityId, createdAt(sort: Desc)])
  @@index([personaId])
  @@index([discordMessageId])
  @@index([messageMetadata], map: "conversation_history_message_metadata_idx", type: Gin)
  @@index([deletedAt]) // For cleanup queries and filtering soft-deleted messages
  @@map("conversation_history")
}

/// Tombstone records for hard-deleted conversation history messages
/// Used by db-sync to prevent resurrection of deleted messages
/// The actual message data is deleted; this just records the deletion event
model ConversationHistoryTombstone {
  id            String   @id @db.Uuid // Same ID as the deleted message
  channelId     String   @map("channel_id") @db.VarChar(20)
  personalityId String   @map("personality_id") @db.Uuid
  personaId     String   @map("persona_id") @db.Uuid
  deletedAt     DateTime @default(now()) @map("deleted_at")

  @@index([channelId, personalityId, personaId])
  @@index([deletedAt]) // For periodic cleanup of old tombstones
  @@map("conversation_history_tombstones")
}

model PendingMemory {
  id                    String               @id @db.Uuid
  conversationHistoryId String?              @unique @map("conversation_history_id") @db.Uuid
  personaId             String               @map("persona_id") @db.Uuid
  personalityId         String               @map("personality_id") @db.Uuid
  text                  String
  metadata              Json
  createdAt             DateTime             @default(now()) @map("created_at")
  attempts              Int                  @default(0)
  lastAttemptAt         DateTime?            @map("last_attempt_at")
  error                 String?
  conversationHistory   ConversationHistory? @relation(fields: [conversationHistoryId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@index([personalityId])
  @@index([createdAt])
  @@index([attempts, createdAt]) // For pending memory retry queries
  @@map("pending_memories")
}

/// Unified channel settings - replaces ActivatedChannel.
/// Stores both activation settings and extended context preferences per channel.
/// Note: channelId is unique (not channelId+personalityId) - one personality per channel.
model ChannelSettings {
  id        String  @id @db.Uuid
  channelId String  @unique @map("channel_id") @db.VarChar(20)
  guildId   String? @map("guild_id") @db.VarChar(20)

  // Activation settings (migrated from ActivatedChannel)
  activatedPersonalityId String? @map("activated_personality_id") @db.Uuid
  autoRespond            Boolean @default(true) @map("auto_respond")

  createdBy String?  @map("created_by") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  createdByUser        User?        @relation(fields: [createdBy], references: [id])
  activatedPersonality Personality? @relation(fields: [activatedPersonalityId], references: [id], onDelete: SetNull)

  @@index([channelId])
  @@index([guildId])
  @@index([activatedPersonalityId])
  @@map("channel_settings")
}

model Memory {
  id                   String                 @id @db.Uuid
  personaId            String?                @map("persona_id") @db.Uuid
  personalityId        String                 @map("personality_id") @db.Uuid
  content              String
  /// Vector embedding for similarity search (BGE-small-en-v1.5: 384 dimensions)
  /// Index: idx_memories_embedding USING ivfflat (embedding vector_cosine_ops) WITH (lists = 50)
  /// Managed outside Prisma - see prisma/drift-ignore.json
  embedding            Unsupported("vector")?
  isSummarized         Boolean                @default(false) @map("is_summarized")
  originalMessageCount Int?                   @map("original_message_count")
  summarizedAt         DateTime?              @map("summarized_at")
  sessionId            String?                @map("session_id") @db.VarChar(255)
  canonScope           String?                @map("canon_scope") @db.VarChar(20)
  summaryType          String?                @map("summary_type") @db.VarChar(50)
  channelId            String?                @map("channel_id") @db.VarChar(20)
  guildId              String?                @map("guild_id") @db.VarChar(20)
  messageIds           String[]               @map("message_ids")
  senders              String[]
  createdAt            DateTime               @default(now()) @map("created_at")
  /// Track when memory content was last modified (for edit history)
  updatedAt            DateTime               @default(now()) @updatedAt @map("updated_at")
  legacyShapesUserId   String?                @map("legacy_shapes_user_id") @db.Uuid
  sourceSystem         String                 @default("tzurot-v3") @map("source_system") @db.VarChar(50)
  /// Protected "core memories" that survive batch delete and purge operations
  isLocked             Boolean                @default(false) @map("is_locked")
  /// Memory visibility: normal, hidden, archived (for future use)
  visibility           String                 @default("normal") @map("visibility") @db.VarChar(20)
  // Chunk linking fields for oversized memories split into multiple chunks
  chunkGroupId         String?                @map("chunk_group_id") @db.Uuid
  chunkIndex           Int?                   @map("chunk_index")
  totalChunks          Int?                   @map("total_chunks")
  persona              Persona?               @relation(fields: [personaId], references: [id], onDelete: Cascade)
  personality          Personality            @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@index([personalityId])
  @@index([createdAt(sort: Desc)])
  @@index([channelId])
  @@index([guildId])
  @@index([sessionId])
  @@index([isSummarized])
  @@index([legacyShapesUserId])
  @@index([sourceSystem])
  // NOTE: isLocked uses a PARTIAL index (WHERE is_locked = true) managed via raw migration
  // for efficient locked memory queries. Declared here for drift detection.
  @@index([isLocked])
  @@index([visibility])
  // NOTE: chunkGroupId uses a PARTIAL index (WHERE chunk_group_id IS NOT NULL)
  // managed via raw migration. Prisma schema declares it for drift detection but
  // the actual index excludes NULL values to save space on non-chunked memories.
  @@index([chunkGroupId])
  // NOTE: The IVFFlat vector index (idx_memories_embedding) is managed outside Prisma
  // because Unsupported types don't support vector-specific operators (VectorCosineOps)
  // See: docs/database/PRISMA_DRIFT_ISSUES.md
  @@map("memories")
}

model ShapesPersonaMapping {
  id                 String   @id @db.Uuid
  shapesUserId       String   @unique @map("shapes_user_id") @db.Uuid
  personaId          String   @map("persona_id") @db.Uuid
  mappedAt           DateTime @default(now()) @map("mapped_at")
  mappedBy           String?  @map("mapped_by") @db.Uuid
  verificationStatus String   @default("unverified") @map("verification_status") @db.VarChar(50)
  persona            Persona  @relation(fields: [personaId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@map("shapes_persona_mappings")
}

model JobResult {
  jobId       String    @id @map("job_id") @db.VarChar(255)
  requestId   String    @map("request_id") @db.VarChar(255)
  result      Json
  status      String    @db.VarChar(50) // PENDING_DELIVERY, DELIVERED
  createdAt   DateTime  @default(now()) @map("created_at")
  completedAt DateTime? @map("completed_at")
  deliveredAt DateTime? @map("delivered_at")

  @@index([status, completedAt])
  @@map("job_results")
}

/// Persistent L2 cache for vision (image) descriptions.
/// Survives Redis restarts and reduces API costs by storing descriptions long-term.
/// L1 (Redis) is checked first; L2 (PostgreSQL) is fallback.
/// Uses Discord attachment snowflake ID as stable cache key.
model ImageDescriptionCache {
  id           String   @id @db.Uuid
  /// Discord attachment snowflake ID - stable identifier for the image
  attachmentId String   @unique @map("attachment_id") @db.VarChar(20)
  /// The generated image description
  description  String
  /// Model that generated the description (for cache invalidation if model changes)
  model        String   @db.VarChar(255)
  /// Failure category for negative caching (null = success, non-null = permanent failure type)
  failureCategory String?  @map("failure_category") @db.VarChar(50)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@map("image_description_cache")
}

/// "Flight recorder" for LLM requests - captures full pipeline data for debugging.
/// Ephemeral: auto-deleted after 24 hours via BullMQ cleanup job.
/// NOTE: Uses @default(uuid()) instead of deterministic UUIDs since this is
/// debug data that doesn't sync between environments.
model LlmDiagnosticLog {
  /// Auto-generated UUID (ephemeral data, no sync needed)
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  /// Link to the request for lookup (e.g., from /admin debug command)
  requestId String @unique @map("request_id") @db.VarChar(255)

  /// Discord message ID that triggered this request (for diagnostic lookup by message)
  triggerMessageId String? @map("trigger_message_id") @db.VarChar(20)

  /// Discord message IDs for AI response chunks (for lookup by response message)
  /// Populated after response is sent to Discord via PATCH endpoint
  responseMessageIds String[] @default([]) @map("response_message_ids")

  /// Top-level indexed fields for filtering/queries
  personalityId String? @map("personality_id") @db.Uuid
  userId        String? @map("user_id") @db.VarChar(20)
  guildId       String? @map("guild_id") @db.VarChar(20)
  channelId     String? @map("channel_id") @db.VarChar(20)
  model         String  @db.VarChar(255)
  provider      String  @db.VarChar(50)
  durationMs    Int     @map("duration_ms")

  /// The full diagnostic payload - see DiagnosticPayload type in ai-worker
  /// Contains: meta, inputContext, assembledPrompt, llmConfig, llmResponse, postProcessing
  data Json

  @@index([createdAt])
  @@index([triggerMessageId])
  @@index([responseMessageIds], type: Gin)
  @@index([personalityId])
  @@index([userId])
  @@index([guildId])
  @@index([channelId])
  @@map("llm_diagnostic_logs")
}

/// Denylist: block specific Discord users or guilds from using the bot.
/// Supports granular scoping: bot-wide, channel-specific, or personality-specific.
/// All denials are silent - the bot simply doesn't respond.
model DenylistedEntity {
  /// Auto-generated UUID (operational data, no sync needed)
  id        String   @id @default(uuid()) @db.Uuid
  /// Entity type: 'USER' or 'GUILD'
  type      String   @db.VarChar(10)
  /// Discord snowflake ID of the user or guild
  discordId String   @map("discord_id") @db.VarChar(20)
  /// Scope of denial: 'BOT' (all), 'CHANNEL' (specific channel), 'PERSONALITY' (specific character)
  scope     String   @default("BOT") @db.VarChar(15)
  /// Target ID for scoped denials. '*' for BOT scope, channel/personality ID otherwise.
  scopeId   String   @default("*") @map("scope_id") @db.VarChar(40)
  /// Optional reason for the denial
  reason    String?  @db.Text
  /// Discord ID of the admin who added this entry
  addedBy   String   @map("added_by") @db.VarChar(20)
  /// When this entry was created
  addedAt   DateTime @default(now()) @map("added_at")

  @@unique([type, discordId, scope, scopeId])
  @@index([type, discordId])
  @@map("denylisted_entities")
}
