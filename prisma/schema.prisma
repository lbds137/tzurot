// Tzurot Database Schema - v3 Redesign
// Clean architecture with no circular dependencies

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// User Management
// ============================================================================

model User {
  id        String @id @default(uuid()) @db.Uuid
  discordId String @unique @map("discord_id") @db.VarChar(20)
  username  String @db.VarChar(255)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations (no circular dependencies!)
  ownedPersonas       Persona[]                @relation("PersonaOwner")
  ownedLlmConfigs     LlmConfig[]              @relation("LlmConfigOwner")
  defaultPersonaLink  UserDefaultPersona?
  personalityOwners   PersonalityOwner[]
  personalityConfigs  UserPersonalityConfig[]
  activatedChannels   ActivatedChannel[]

  @@index([discordId])
  @@map("users")
}

// ============================================================================
// Reusable Configuration Templates
// ============================================================================

model Persona {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @db.VarChar(255)
  description String? @db.Text
  content     String  @db.Text // The actual persona/backstory text

  // User personalization fields
  preferredName String? @map("preferred_name") @db.VarChar(255)
  pronouns      String? @db.VarChar(100)

  // Ownership - REQUIRED (every persona has an owner)
  ownerId String @map("owner_id") @db.Uuid
  owner   User   @relation("PersonaOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  usersUsingAsDefault  UserDefaultPersona[]
  personalityConfigs   UserPersonalityConfig[]
  conversationHistory  ConversationHistory[]

  @@index([ownerId])
  @@map("personas")
}

// Tracks each user's default persona (no circular dependency)
model UserDefaultPersona {
  userId String @unique @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  personaId String  @map("persona_id") @db.Uuid
  persona   Persona @relation(fields: [personaId], references: [id], onDelete: Cascade)

  updatedAt DateTime @updatedAt @map("updated_at")

  @@id([userId])
  @@index([personaId])
  @@map("user_default_personas")
}

model SystemPrompt {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @db.VarChar(255)
  description String? @db.Text
  content     String  @db.Text
  isDefault   Boolean @default(false) @map("is_default")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  personalities Personality[]

  @@index([isDefault])
  @@map("system_prompts")
}

model LlmConfig {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @db.VarChar(255)
  description String? @db.Text

  // Ownership - nullable for global configs, set for user-owned
  ownerId  String?  @map("owner_id") @db.Uuid
  owner    User?    @relation("LlmConfigOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  isGlobal Boolean  @default(false) @map("is_global")
  isDefault Boolean @default(false) @map("is_default")

  // LLM parameters
  model             String   @db.VarChar(255)
  visionModel       String?  @map("vision_model") @db.VarChar(255)
  temperature       Decimal? @db.Decimal(3, 2)
  topP              Decimal? @map("top_p") @db.Decimal(3, 2)
  topK              Int?     @map("top_k")
  frequencyPenalty  Decimal? @map("frequency_penalty") @db.Decimal(3, 2)
  presencePenalty   Decimal? @map("presence_penalty") @db.Decimal(3, 2)
  repetitionPenalty Decimal? @map("repetition_penalty") @db.Decimal(3, 2)
  maxTokens         Int?     @map("max_tokens")

  // Memory settings (LTM and STM)
  memoryScoreThreshold Decimal? @map("memory_score_threshold") @db.Decimal(3, 2)
  memoryLimit          Int?     @map("memory_limit")
  contextWindowSize    Int      @default(20) @map("context_window_size") // Moved from Personality

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  personalitiesUsingAsDefault PersonalityDefaultConfig[]
  userPersonalityConfigs      UserPersonalityConfig[]

  @@index([ownerId])
  @@index([isGlobal])
  @@map("llm_configs")
}

// Tracks each personality's default LLM config (no circular dependency)
model PersonalityDefaultConfig {
  personalityId String      @unique @map("personality_id") @db.Uuid
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  llmConfigId String    @map("llm_config_id") @db.Uuid
  llmConfig   LlmConfig @relation(fields: [llmConfigId], references: [id], onDelete: Cascade)

  updatedAt DateTime @updatedAt @map("updated_at")

  @@id([personalityId])
  @@index([llmConfigId])
  @@map("personality_default_configs")
}

// ============================================================================
// Personalities
// ============================================================================

model Personality {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @db.VarChar(255)
  displayName String? @map("display_name") @db.VarChar(255)
  slug        String  @unique @db.VarChar(255)

  // Core behavior
  systemPromptId String?       @map("system_prompt_id") @db.Uuid
  systemPrompt   SystemPrompt? @relation(fields: [systemPromptId], references: [id], onDelete: SetNull)

  // Default LLM config tracked in separate table (no FK here)

  // Character definition
  characterInfo          String  @map("character_info") @db.Text
  personalityTraits      String  @map("personality_traits") @db.Text
  personalityTone        String? @map("personality_tone") @db.VarChar(500)
  personalityAge         String? @map("personality_age") @db.VarChar(100)
  personalityAppearance  String? @map("personality_appearance") @db.Text
  personalityLikes       String? @map("personality_likes") @db.Text
  personalityDislikes    String? @map("personality_dislikes") @db.Text
  conversationalGoals    String? @map("conversational_goals") @db.Text
  conversationalExamples String? @map("conversational_examples") @db.Text
  customFields           Json?   @map("custom_fields")

  // Voice settings
  voiceEnabled  Boolean @default(false) @map("voice_enabled")
  voiceSettings Json?   @map("voice_settings")

  // Image settings
  imageEnabled  Boolean @default(false) @map("image_enabled")
  imageSettings Json?   @map("image_settings")

  // Avatar (stored as base64-encoded PNG)
  avatarData String? @map("avatar_data") @db.Text

  // Memory settings
  memoryEnabled Boolean @default(true) @map("memory_enabled")
  // contextWindowSize removed - now in LlmConfig

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  owners              PersonalityOwner[]
  defaultConfigLink   PersonalityDefaultConfig?
  userConfigs         UserPersonalityConfig[]
  conversationHistory ConversationHistory[]
  activatedChannels   ActivatedChannel[]

  @@index([slug])
  @@map("personalities")
}

model PersonalityOwner {
  personalityId String      @map("personality_id") @db.Uuid
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role String @default("owner") @db.VarChar(50) // 'owner', 'editor', 'viewer'

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@id([personalityId, userId])
  @@index([userId])
  @@index([personalityId])
  @@map("personality_owners")
}

// User-specific overrides for personality configuration
model UserPersonalityConfig {
  id String @id @default(uuid()) @db.Uuid

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  personalityId String      @map("personality_id") @db.Uuid
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  // Override user's default persona for this specific personality
  personaId String?  @map("persona_id") @db.Uuid
  persona   Persona? @relation(fields: [personaId], references: [id], onDelete: SetNull)

  // Override LLM config for this user+personality combo
  llmConfigId String?    @map("llm_config_id") @db.Uuid
  llmConfig   LlmConfig? @relation(fields: [llmConfigId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([userId, personalityId])
  @@index([userId])
  @@index([personalityId])
  @@map("user_personality_configs")
}

// ============================================================================
// Conversation Management
// ============================================================================

model ConversationHistory {
  id String @id @default(uuid()) @db.Uuid

  channelId String @map("channel_id") @db.VarChar(20)

  personalityId String      @map("personality_id") @db.Uuid
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  // Persona isolation - conversations are segmented by persona, not user
  // This aligns STM (PostgreSQL) with LTM (Qdrant vector store)
  personaId String  @map("persona_id") @db.Uuid
  persona   Persona @relation(fields: [personaId], references: [id], onDelete: Cascade)

  role    String @db.VarChar(20) // 'user', 'assistant', 'system'
  content String @db.Text

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  pendingMemory PendingMemory?

  @@index([channelId, personalityId, createdAt(sort: Desc)])
  @@index([personaId])
  @@map("conversation_history")
}

// Pending memories - tracks memories that need to be synced to Qdrant
// Gets cleaned up after successful Qdrant storage
model PendingMemory {
  id                    String   @id @default(uuid()) @db.Uuid
  conversationHistoryId String   @unique @map("conversation_history_id") @db.Uuid
  personaId             String   @map("persona_id") @db.Uuid
  personalityId         String   @map("personality_id") @db.Uuid
  personalityName       String?  @map("personality_name") @db.VarChar(255)
  text                  String   @db.Text // The formatted interaction text
  metadata              Json     // All the metadata for Qdrant
  createdAt             DateTime @default(now()) @map("created_at")
  attempts              Int      @default(0)
  lastAttemptAt         DateTime? @map("last_attempt_at")
  error                 String?  @db.Text

  conversationHistory   ConversationHistory @relation(fields: [conversationHistoryId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@index([personalityId])
  @@index([createdAt])
  @@map("pending_memories")
}

model ActivatedChannel {
  id String @id @default(uuid()) @db.Uuid

  channelId String @map("channel_id") @db.VarChar(20)

  personalityId String      @map("personality_id") @db.Uuid
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  autoRespond Boolean @default(true) @map("auto_respond")

  createdBy     String? @map("created_by") @db.Uuid
  createdByUser User?   @relation(fields: [createdBy], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([channelId, personalityId])
  @@index([channelId])
  @@index([personalityId])
  @@map("activated_channels")
}
