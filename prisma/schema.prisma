generator client {
  provider        = "prisma-client"
  output          = "../packages/common-types/src/generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

/// NOTE: All models use explicit IDs (no @default(uuid())) to enforce deterministic UUIDs.
/// This project syncs data between dev and prod - random UUIDs cause sync failures.
/// Application code MUST provide IDs using generators from deterministicUuid.ts.
/// See CLAUDE.md "Deterministic UUIDs Required" section.
model User {
  id                    String                     @id @db.Uuid
  discordId             String                     @unique @map("discord_id") @db.VarChar(20)
  username              String                     @db.VarChar(255)
  timezone              String                     @default("UTC") @db.VarChar(50)
  isSuperuser           Boolean                    @default(false) @map("is_superuser")
  defaultLlmConfigId    String?                    @map("default_llm_config_id") @db.Uuid
  defaultPersonaId      String?                    @map("default_persona_id") @db.Uuid
  createdAt             DateTime                   @default(now()) @map("created_at")
  updatedAt             DateTime                   @updatedAt @map("updated_at")
  apiKeys               UserApiKey[]
  usageLogs             UsageLog[]
  channelSettings       ChannelSettings[]
  adminSettingsUpdates  AdminSettings[]
  botSettingsUpdates    BotSettings[] // @deprecated - for migration only
  defaultLlmConfig      LlmConfig?                 @relation("UserDefaultLlmConfig", fields: [defaultLlmConfigId], references: [id], onDelete: SetNull)
  defaultPersona        Persona?                   @relation("UserDefaultPersona", fields: [defaultPersonaId], references: [id], onDelete: SetNull)
  ownedLlmConfigs       LlmConfig[]                @relation("LlmConfigOwner")
  ownedPersonalities    Personality[]              @relation("PersonalityOwner")
  personalityOwners     PersonalityOwner[]
  ownedPersonas         Persona[]                  @relation("PersonaOwner")
  personalityConfigs    UserPersonalityConfig[]
  personaHistoryConfigs UserPersonaHistoryConfig[]

  @@index([discordId])
  @@index([defaultLlmConfigId])
  @@index([defaultPersonaId])
  @@map("users")
}

/// Tracks API usage per user for monitoring, billing, and abuse prevention.
/// Even with BYOK, we track usage to prevent infrastructure abuse.
model UsageLog {
  id          String   @id @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  provider    String   @db.VarChar(20)
  model       String   @db.VarChar(255)
  tokensIn    Int      @map("tokens_in")
  tokensOut   Int      @map("tokens_out")
  requestType String   @map("request_type") @db.VarChar(50)
  createdAt   DateTime @default(now()) @map("created_at")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([provider]) // For admin queries filtering by provider across all users
  @@index([userId, createdAt])
  @@index([userId, provider])
  @@index([userId, provider, createdAt]) // For per-provider usage queries with date range
  @@map("usage_logs")
}

/// Global admin settings for bot-wide defaults.
/// Singleton row - only one row should exist (enforced by application code).
/// Replaces the old key-value BotSettings model with proper typed columns.
model AdminSettings {
  id        String   @id @db.Uuid
  updatedBy String?  @map("updated_by") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Extended Context Settings
  /// Global default for extended context (channel/personality can override)
  extendedContextDefault     Boolean @default(true) @map("extended_context_default")
  /// Default max messages to fetch (hard cap: 100)
  extendedContextMaxMessages Int     @default(20) @map("extended_context_max_messages")
  /// Max age for messages in seconds (null = no limit/disabled)
  extendedContextMaxAge      Int?    @map("extended_context_max_age")
  /// Max images to proactively process (0 = disabled)
  extendedContextMaxImages   Int     @default(0) @map("extended_context_max_images")

  updatedByUser User? @relation(fields: [updatedBy], references: [id])

  @@map("admin_settings")
}

/// @deprecated Legacy key-value settings - use AdminSettings instead.
/// Kept for migration purposes only. Will be removed in future release.
model BotSettings {
  id          String   @id @db.Uuid
  key         String   @unique @db.VarChar(100)
  value       String   @db.Text
  description String?  @db.Text
  updatedBy   String?  @map("updated_by") @db.Uuid
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  updatedByUser User? @relation(fields: [updatedBy], references: [id])

  @@map("bot_settings")
}

/// Encrypted API keys for BYOK (Bring Your Own Key) support.
/// Uses AES-256-GCM encryption with separate columns for iv, content, and tag.
model UserApiKey {
  id         String    @id @db.Uuid
  userId     String    @map("user_id") @db.Uuid
  provider   String    @default("openrouter") @db.VarChar(20)
  iv         String    @db.VarChar(32)
  content    String    @db.Text
  tag        String    @db.VarChar(32)
  isActive   Boolean   @default(true) @map("is_active")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  lastUsedAt DateTime? @map("last_used_at")
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@index([provider])
  @@map("user_api_keys")
}

model Persona {
  id                          String                     @id @db.Uuid
  name                        String                     @db.VarChar(255)
  description                 String?
  content                     String
  preferredName               String?                    @map("preferred_name") @db.VarChar(255)
  pronouns                    String?                    @db.VarChar(100)
  shareLtmAcrossPersonalities Boolean                    @default(false) @map("share_ltm_across_personalities")
  ownerId                     String                     @map("owner_id") @db.Uuid
  createdAt                   DateTime                   @default(now()) @map("created_at")
  updatedAt                   DateTime                   @updatedAt @map("updated_at")
  conversationHistory         ConversationHistory[]
  memories                    Memory[]
  owner                       User                       @relation("PersonaOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  usersWithAsDefault          User[]                     @relation("UserDefaultPersona")
  shapesPersonaMappings       ShapesPersonaMapping[]
  personalityConfigs          UserPersonalityConfig[]
  historyConfigs              UserPersonaHistoryConfig[] @relation("personaHistoryConfigs")

  @@index([ownerId])
  @@map("personas")
}

model SystemPrompt {
  id            String        @id @db.Uuid
  name          String        @db.VarChar(255)
  description   String?
  content       String
  isDefault     Boolean       @default(false) @map("is_default")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")
  personalities Personality[]

  @@index([isDefault])
  @@map("system_prompts")
}

model LlmConfig {
  id                          String                     @id @db.Uuid
  name                        String                     @db.VarChar(255)
  description                 String?
  ownerId                     String?                    @map("owner_id") @db.Uuid
  isGlobal                    Boolean                    @default(false) @map("is_global")
  isDefault                   Boolean                    @default(false) @map("is_default")
  /// Default config for guest mode (users without API keys). Only one should be true.
  /// Enforced by partial unique index: llm_configs_free_default_unique (WHERE is_free_default = true)
  isFreeDefault               Boolean                    @default(false) @map("is_free_default")
  provider                    String                     @default("openrouter") @db.VarChar(20)
  model                       String                     @db.VarChar(255)
  visionModel                 String?                    @map("vision_model") @db.VarChar(255)
  /// New JSONB field for provider-specific parameters (temperature, reasoning, etc.)
  /// See AdvancedParamsSchema in common-types for validation
  advancedParameters          Json?                      @map("advanced_parameters")
  maxReferencedMessages       Int                        @default(20) @map("max_referenced_messages")
  // Legacy columns - will be migrated to advancedParameters in Step B
  temperature                 Decimal?                   @db.Decimal(3, 2)
  topP                        Decimal?                   @map("top_p") @db.Decimal(3, 2)
  topK                        Int?                       @map("top_k")
  frequencyPenalty            Decimal?                   @map("frequency_penalty") @db.Decimal(3, 2)
  presencePenalty             Decimal?                   @map("presence_penalty") @db.Decimal(3, 2)
  repetitionPenalty           Decimal?                   @map("repetition_penalty") @db.Decimal(3, 2)
  maxTokens                   Int?                       @map("max_tokens")
  memoryScoreThreshold        Decimal?                   @map("memory_score_threshold") @db.Decimal(3, 2)
  memoryLimit                 Int?                       @map("memory_limit")
  contextWindowTokens         Int                        @default(131072) @map("context_window_tokens")
  createdAt                   DateTime                   @default(now()) @map("created_at")
  updatedAt                   DateTime                   @updatedAt @map("updated_at")
  owner                       User?                      @relation("LlmConfigOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  personalitiesUsingAsDefault PersonalityDefaultConfig[]
  userPersonalityConfigs      UserPersonalityConfig[]
  usersWithAsDefault          User[]                     @relation("UserDefaultLlmConfig")

  @@index([ownerId])
  @@index([isGlobal])
  @@index([isFreeDefault])
  @@map("llm_configs")
}

model PersonalityDefaultConfig {
  personalityId String      @id @unique @map("personality_id") @db.Uuid
  llmConfigId   String      @map("llm_config_id") @db.Uuid
  updatedAt     DateTime    @updatedAt @map("updated_at")
  llmConfig     LlmConfig   @relation(fields: [llmConfigId], references: [id], onDelete: Cascade)
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  @@index([llmConfigId])
  @@map("personality_default_configs")
}

model Personality {
  id                      String                     @id @db.Uuid
  name                    String                     @db.VarChar(255)
  displayName             String?                    @map("display_name") @db.VarChar(255)
  slug                    String                     @unique @db.VarChar(255)
  systemPromptId          String?                    @map("system_prompt_id") @db.Uuid
  ownerId                 String?                    @map("owner_id") @db.Uuid
  characterInfo           String                     @map("character_info")
  personalityTraits       String                     @map("personality_traits")
  personalityTone         String?                    @map("personality_tone")
  personalityAge          String?                    @map("personality_age")
  personalityAppearance   String?                    @map("personality_appearance")
  personalityLikes        String?                    @map("personality_likes")
  personalityDislikes     String?                    @map("personality_dislikes")
  conversationalGoals     String?                    @map("conversational_goals")
  conversationalExamples  String?                    @map("conversational_examples")
  customFields            Json?                      @map("custom_fields")
  errorMessage            String?                    @map("error_message")
  birthMonth              Int?                       @map("birth_month")
  birthDay                Int?                       @map("birth_day")
  birthYear               Int?                       @map("birth_year")
  isPublic                Boolean                    @default(true) @map("is_public")
  voiceEnabled            Boolean                    @default(false) @map("voice_enabled")
  voiceSettings           Json?                      @map("voice_settings")
  imageEnabled            Boolean                    @default(false) @map("image_enabled")
  imageSettings           Json?                      @map("image_settings")
  avatarData              Bytes?                     @map("avatar_data")
  // Extended context settings (null = inherit from channel/global hierarchy)
  /// Tri-state: null=auto, true=on, false=off (see docs/standards/TRI_STATE_PATTERN.md)
  extendedContext           Boolean?                   @map("extended_context")
  /// Max messages to fetch (null = follow channel/global)
  extendedContextMaxMessages Int?                      @map("extended_context_max_messages")
  /// Max age in seconds (null = follow channel/global)
  extendedContextMaxAge      Int?                      @map("extended_context_max_age")
  /// Max images to process (null = follow channel/global)
  extendedContextMaxImages   Int?                      @map("extended_context_max_images")

  createdAt               DateTime                   @default(now()) @map("created_at")
  updatedAt               DateTime                   @updatedAt @map("updated_at")
  channelSettings         ChannelSettings[]
  aliases                 PersonalityAlias[]
  conversationHistory     ConversationHistory[]
  memories                Memory[]
  owner                   User?                      @relation("PersonalityOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  systemPrompt            SystemPrompt?              @relation(fields: [systemPromptId], references: [id])
  defaultConfigLink       PersonalityDefaultConfig?
  owners                  PersonalityOwner[]
  userConfigs             UserPersonalityConfig[]
  personaHistoryConfigs   UserPersonaHistoryConfig[]

  @@index([slug])
  @@index([ownerId])
  @@map("personalities")
}

model PersonalityOwner {
  personalityId String      @map("personality_id") @db.Uuid
  userId        String      @map("user_id") @db.Uuid
  role          String      @default("owner") @db.VarChar(50)
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([personalityId, userId])
  @@index([userId])
  @@index([personalityId])
  @@map("personality_owners")
}

/// Aliases for personalities (e.g., "lily" -> lilith, "sassy" -> sarcastic)
/// Enables users to reference personalities by multiple names
model PersonalityAlias {
  id            String      @id @db.Uuid
  alias         String      @unique @db.VarChar(100)
  personalityId String      @map("personality_id") @db.Uuid
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  personality   Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  @@index([personalityId])
  @@map("personality_aliases")
}

/// User-specific overrides for a personality (persona, LLM config)
/// Note: STM epoch fields (lastContextReset) are in UserPersonaHistoryConfig,
/// which tracks per-persona history (user + personality + persona).
model UserPersonalityConfig {
  id            String   @id @db.Uuid
  userId        String   @map("user_id") @db.Uuid
  personalityId String   @map("personality_id") @db.Uuid
  personaId     String?  @map("persona_id") @db.Uuid
  llmConfigId   String?  @map("llm_config_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  llmConfig   LlmConfig?  @relation(fields: [llmConfigId], references: [id])
  persona     Persona?    @relation(fields: [personaId], references: [id])
  personality Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, personalityId])
  @@index([userId])
  @@index([personalityId])
  @@map("user_personality_configs")
}

/// Per-persona history configuration (epoch tracking for memory commands)
/// This enables each persona to have independent conversation history cutoffs
/// See ADR-003 in docs/planning/SLASH_COMMAND_ARCHITECTURE.md
model UserPersonaHistoryConfig {
  id            String   @id @db.Uuid
  userId        String   @map("user_id") @db.Uuid
  personalityId String   @map("personality_id") @db.Uuid
  personaId     String   @map("persona_id") @db.Uuid
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // STM Epoch System - Non-destructive conversation history filtering per-persona
  // Messages older than lastContextReset are excluded from AI context
  lastContextReset     DateTime? @map("last_context_reset")
  previousContextReset DateTime? @map("previous_context_reset") // For undo support

  persona     Persona     @relation("personaHistoryConfigs", fields: [personaId], references: [id], onDelete: Cascade)
  personality Personality @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, personalityId, personaId])
  @@index([userId])
  @@index([personalityId])
  @@index([personaId])
  @@map("user_persona_history_configs")
}

model ConversationHistory {
  id               String         @id @db.Uuid
  channelId        String         @map("channel_id") @db.VarChar(20)
  guildId          String?        @map("guild_id") @db.VarChar(20) // Null for DMs
  personalityId    String         @map("personality_id") @db.Uuid
  personaId        String         @map("persona_id") @db.Uuid
  role             String         @db.VarChar(20)
  content          String
  tokenCount       Int?           @map("token_count") // Cached token count (null for old messages)
  discordMessageId String[]       @default([]) @map("discord_message_id") // Discord snowflake IDs for chunked messages (deduplication)
  /// Structured metadata for the message (referenced messages, attachments, etc.)
  /// Separates semantic content (in 'content') from contextual data
  /// See MessageMetadata interface in common-types for schema
  messageMetadata  Json?          @default("{}") @map("message_metadata")
  /// Soft delete timestamp - message excluded from context when set
  /// Used for opportunistic sync when Discord message is deleted
  deletedAt        DateTime?      @map("deleted_at")
  /// Last edit detected timestamp - updated during opportunistic sync
  /// when Discord message content differs from stored content
  editedAt         DateTime?      @map("edited_at")
  createdAt        DateTime       @default(now()) @map("created_at")
  persona          Persona        @relation(fields: [personaId], references: [id], onDelete: Cascade)
  personality      Personality    @relation(fields: [personalityId], references: [id], onDelete: Cascade)
  pendingMemory    PendingMemory?

  @@index([channelId, personalityId, createdAt(sort: Desc)])
  @@index([personaId])
  @@index([discordMessageId])
  @@index([messageMetadata], map: "conversation_history_message_metadata_idx", type: Gin)
  @@index([deletedAt]) // For cleanup queries and filtering soft-deleted messages
  @@map("conversation_history")
}

/// Tombstone records for hard-deleted conversation history messages
/// Used by db-sync to prevent resurrection of deleted messages
/// The actual message data is deleted; this just records the deletion event
model ConversationHistoryTombstone {
  id            String   @id @db.Uuid // Same ID as the deleted message
  channelId     String   @map("channel_id") @db.VarChar(20)
  personalityId String   @map("personality_id") @db.Uuid
  personaId     String   @map("persona_id") @db.Uuid
  deletedAt     DateTime @default(now()) @map("deleted_at")

  @@index([channelId, personalityId, personaId])
  @@index([deletedAt]) // For periodic cleanup of old tombstones
  @@map("conversation_history_tombstones")
}

model PendingMemory {
  id                    String               @id @db.Uuid
  conversationHistoryId String?              @unique @map("conversation_history_id") @db.Uuid
  personaId             String               @map("persona_id") @db.Uuid
  personalityId         String               @map("personality_id") @db.Uuid
  text                  String
  metadata              Json
  createdAt             DateTime             @default(now()) @map("created_at")
  attempts              Int                  @default(0)
  lastAttemptAt         DateTime?            @map("last_attempt_at")
  error                 String?
  conversationHistory   ConversationHistory? @relation(fields: [conversationHistoryId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@index([personalityId])
  @@index([createdAt])
  @@index([attempts, createdAt]) // For pending memory retry queries
  @@map("pending_memories")
}

/// Unified channel settings - replaces ActivatedChannel.
/// Stores both activation settings and extended context preferences per channel.
/// Note: channelId is unique (not channelId+personalityId) - one personality per channel.
model ChannelSettings {
  id        String  @id @db.Uuid
  channelId String  @unique @map("channel_id") @db.VarChar(20)
  guildId   String? @map("guild_id") @db.VarChar(20)

  // Activation settings (migrated from ActivatedChannel)
  activatedPersonalityId String? @map("activated_personality_id") @db.Uuid
  autoRespond            Boolean @default(true) @map("auto_respond")

  // Extended context settings (null = inherit from AdminSettings global defaults)
  /// Tri-state: null=auto (follow global), true=on, false=off
  extendedContext           Boolean? @map("extended_context")
  /// Max messages to fetch (null = follow global)
  extendedContextMaxMessages Int?    @map("extended_context_max_messages")
  /// Max age in seconds (null = follow global)
  extendedContextMaxAge      Int?    @map("extended_context_max_age")
  /// Max images to process (null = follow global)
  extendedContextMaxImages   Int?    @map("extended_context_max_images")

  createdBy String?  @map("created_by") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  createdByUser        User?        @relation(fields: [createdBy], references: [id])
  activatedPersonality Personality? @relation(fields: [activatedPersonalityId], references: [id], onDelete: SetNull)

  @@index([channelId])
  @@index([guildId])
  @@index([activatedPersonalityId])
  @@map("channel_settings")
}

model Memory {
  id                   String                 @id @db.Uuid
  personaId            String?                @map("persona_id") @db.Uuid
  personalityId        String                 @map("personality_id") @db.Uuid
  content              String
  /// Vector embedding for similarity search - managed outside Prisma
  /// Index: idx_memories_embedding USING ivfflat (embedding vector_cosine_ops) WITH (lists = 50)
  embedding            Unsupported("vector")?
  isSummarized         Boolean                @default(false) @map("is_summarized")
  originalMessageCount Int?                   @map("original_message_count")
  summarizedAt         DateTime?              @map("summarized_at")
  sessionId            String?                @map("session_id") @db.VarChar(255)
  canonScope           String?                @map("canon_scope") @db.VarChar(20)
  summaryType          String?                @map("summary_type") @db.VarChar(50)
  channelId            String?                @map("channel_id") @db.VarChar(20)
  guildId              String?                @map("guild_id") @db.VarChar(20)
  messageIds           String[]               @map("message_ids")
  senders              String[]
  createdAt            DateTime               @default(now()) @map("created_at")
  legacyShapesUserId   String?                @map("legacy_shapes_user_id") @db.Uuid
  sourceSystem         String                 @default("tzurot-v3") @map("source_system") @db.VarChar(50)
  // Chunk linking fields for oversized memories split into multiple chunks
  chunkGroupId         String?                @map("chunk_group_id") @db.Uuid
  chunkIndex           Int?                   @map("chunk_index")
  totalChunks          Int?                   @map("total_chunks")
  persona              Persona?               @relation(fields: [personaId], references: [id], onDelete: Cascade)
  personality          Personality            @relation(fields: [personalityId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@index([personalityId])
  @@index([createdAt(sort: Desc)])
  @@index([channelId])
  @@index([guildId])
  @@index([sessionId])
  @@index([isSummarized])
  @@index([legacyShapesUserId])
  @@index([sourceSystem])
  // NOTE: chunkGroupId uses a PARTIAL index (WHERE chunk_group_id IS NOT NULL)
  // managed via raw migration. Prisma schema declares it for drift detection but
  // the actual index excludes NULL values to save space on non-chunked memories.
  @@index([chunkGroupId])
  // NOTE: The IVFFlat vector index (idx_memories_embedding) is managed outside Prisma
  // because Unsupported types don't support vector-specific operators (VectorCosineOps)
  // See: docs/database/PRISMA_DRIFT_ISSUES.md
  @@map("memories")
}

model ShapesPersonaMapping {
  id                 String   @id @db.Uuid
  shapesUserId       String   @unique @map("shapes_user_id") @db.Uuid
  personaId          String   @map("persona_id") @db.Uuid
  mappedAt           DateTime @default(now()) @map("mapped_at")
  mappedBy           String?  @map("mapped_by") @db.Uuid
  verificationStatus String   @default("unverified") @map("verification_status") @db.VarChar(50)
  persona            Persona  @relation(fields: [personaId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@map("shapes_persona_mappings")
}

model JobResult {
  jobId       String    @id @map("job_id") @db.VarChar(255)
  requestId   String    @map("request_id") @db.VarChar(255)
  result      Json
  status      String    @db.VarChar(50) // PENDING_DELIVERY, DELIVERED
  createdAt   DateTime  @default(now()) @map("created_at")
  completedAt DateTime? @map("completed_at")
  deliveredAt DateTime? @map("delivered_at")

  @@index([status, completedAt])
  @@map("job_results")
}

/// Persistent L2 cache for vision (image) descriptions.
/// Survives Redis restarts and reduces API costs by storing descriptions long-term.
/// L1 (Redis) is checked first; L2 (PostgreSQL) is fallback.
/// Uses Discord attachment snowflake ID as stable cache key.
model ImageDescriptionCache {
  id           String   @id @db.Uuid
  /// Discord attachment snowflake ID - stable identifier for the image
  attachmentId String   @unique @map("attachment_id") @db.VarChar(20)
  /// The generated image description
  description  String
  /// Model that generated the description (for cache invalidation if model changes)
  model        String   @db.VarChar(255)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@map("image_description_cache")
}
